How to
======

These tutorials will guide you through the process of generating your own own customized GUI and measurement routines.

Before we can start, please follow the steps in chapter :ref:`Your first GUI` and create an empty new Project with the name of your liking.

Add a GUI element
-----------------

Your program has - most likely - no productive GUI elements at all, if its want you wanted: *Awesome*. If not, we ought to change that.
In order to do so we need to design a GUI first.

COMET can work with **QTDesigner** ``.ui`` files.
With the :ref:`installation` of this software, which you have followed I hope, the so-called QtDesigner was installed as well.
If features a simple GUI based program, in which you can generate your own GUI and save them in ``.ui`` format.

.. note:: You can normally find the QTDesigner in your install directory of python under the QT directory in the lib. And I will not go into details on how you build GUIs in QtDesigner, there are plenty of tutorial videos in the web.

When your GUI element is finished save it in the directory ``.UniDAQ/QT_Designer_UI``. Now COMET can access them easily.

The next step is to tell the Program to render this UI. Open the ``settings.yml`` in your project folder and
add in the parameter ``GUI_render_order`` with a list value of ``<YourCoolGUI>``. ::

    GUI_render_order:
        - YourCoolGUI
        - DeviceCommunication
        - Resources
        - DataBrowser

Unfortunately this is not all. We know have to write some code to tell the framework that we want to render this ``.ui`` file you have just created.
For this we generate a file in the directory ``.UniDAQ/ui_plugins``. This file you have to call ``<YourCoolGUI>_window.py``.

.. note:: It is important, that you add the suffix ``_window`` to your python file, this makes it clear for the framework, that this is a window and treads it as one. All other files will be ignored and cannot be added this way!

Inside your python GUI plugin you have to direct the framework what to do.
The minimal example to run just the GUI without anything else is as follows: ::

    from PyQt5 import QtGui
    from PyQt5.QtGui import *
    from PyQt5.QtWidgets import *
    import logging

    class <YourCoolGUI>_window:
        def __init__(self, GUI_classes, layout):
            self.variables = GUI_classes    # Containing all variables and methods from the parent class for example the state machine
            self.layout = layout            # The layout class in which will be rendered
            self.log = logging.getLogger(__name__) # This is optional, but you do want to write to the logger

            # Loading the UI plugin
            <YourCoolGUI>_widget = QWidget()
            self.<YourCoolGUI> = self.variables.load_QtUi_file("./UniDAQ/QT_Designer_UI/<YourCoolGUI>", <YourCoolGUI>_widget)
            self.layout.addWidget(<YourCoolGUI>_widget)

After that it renders the GUI when you restart COMET. But this code does not have and logic to it. You can add python
member functions to it. To access the ui classes from your GUI e.g. buttons and so on, you have to do it via ``self.<YourCoolGUI>.foo()`` etc.

If you restart COMET you should see a window tab called "<YourCoolGUI>". Wow, what an achievement!
Now that we know how to add some GUI elements to our program we can proceed and add some devices too.

Add a new device
----------------

Before we start with this tutorial make sure you have added the "Resource" tab to your GUI as described in the previous chapter or in the chatper :ref:`Your first GUI`.
This will make it easy to see if a new device was added or not.

Now that we have a GUI which can display all devices in the framework, we should add a device and see what happens.
To do so add the line: ::

    Devices: # Name of the config entry
      <Device_descriptor>: # Some descriptor for the device
        Device_name: <A Device name>  # Name of the device, this must be the same name as of one in the device library                                                                # The actual device name from which it should get all commands
        Device_IDN: <IDN of your specific device>
        Connection_type: <Connection type>

The top entry **Devices** is a mandatory entry which tells the software that the following entries are devices.
The sub-entries are up to your liking, but this will be the name of the internal representation of the device object in the software!

The entires:
   * Device_name
   * Device_IDN
   * Connection_type

are mandatory for eacht sub-entries. You can extend this list as you like, the main framework will ignore them, but if you do need some additional parameters which cannot
be configured in the main device config, knock yourself out.

.. note:: If you have a RS232 device connected you can add the ``Baud_rate`` parameter and change the default baud rate for the device. This also holds true for other RS232 parameters. For more information see, the device connection API reference for more information.

**Connection_type** is a parameter which tells the framework what kind of connection the device listens to and at what port.
Possible options are:
   * RS232:<ComPort>
   * GPIB:<Address>
   * IP:<IP_INSTR_descriptor>

If you then start the COMET software with your project selected. The device should appear in the resources tab. Depending if
the device is connected to the PC the connection lamp should switch to green, which means that the software has successfully established
a connection to the device and everything was configured correctly.

.. note:: Most often, if you experience connection difficulties the Device_IDN is not completely correct entered.

The result schould lool like this:

.. image:: pictures/Resources.png
   :alt: Flowchart_main
   :class: floatingflask


COMET furthermore knows the concept of alias names for devices.
This enables you to have an easy way to relabel devices and assign devices to more than one task. Imagine you have a device which
does some switching and can monitor the environment as well. Either you load the device twice with a different name and so on. Or you
assign an alias e.g. 1) "HV Switching" and 2) "Humidity Monitor" to the device. For the user it then looks like two devices but internally its the same device.
This prevents async. read and write operations to the device and makes it more robust.

To tell COMET to assign a alias to on device have a look at a specific example: ::

   # Devices aliases for internal use, the key will then be the frameworks internal representation and the value is the display name
    Aliases:
        temphum_controller: BrandBox
        HVSwitching: BrandBox
        BiasSMU: 2470 Keithley SMU
        lights_controller: BrandBox

    Devices:
        2470SMU:
            Device_name: 2470 Keithley SMU
            Device_IDN: KEITHLEY INSTRUMENTS,MODEL 2470,04424944,1.6.8d
            Connection_type: IP:TCPIP0::192.168.130.131::inst0::INSTR

        BrandBox:
            Device_name: BrandBox
            Connection_type: RS232:15
            Device_IDN: HV-Relay Controller V1.6/18.Apr.2019

In this case the device "2470 Keithley SMU" will be renamed to "BiasSMU" and the device "BrandBox" will be devices
"temphum_controller", "HVSwitching", and "lights_controller". Which internally, e.g. in your measurement plugin can directly be addressed with these names.

Create a new device
-------------------

COMET ships with a large variety of different devices which have been preconfigured for easy use.
If you have a device which is not listed you have to add this device to the lib. To do so look in the directory, ``configs\device_lib``.
There you can add your device as as ``.yml`` styled file. You can choose the name of the file as you see fit. As long it does not
interfere with another name in the same directory.

.. note:: The software only accepts ``.yml`` files, all other files will be ignored.

Inside such a device file you can set a multitude of parameters. Such a exemplary device file looks as follows: ::

   ---
   Device_name: 2470 Keithley SMU   # Device name, the name you have to state in the settings file
   Display_name: BiasSMU # Some easy to read name for the user
   Device_type: SMU # Some descriptor what kind of device it is

   # All set parameters
   set_beep: beeper.beep({}, {})
   set_delay: delay({}) # Sets a delay to to following command!
   set_meas_delay: smu.measure.userdelay[1] = {}
   set_measurement_function: smu.measure.func = {} #  smu.FUNC_DC_VOLTAGE/smu.FUNC_DC_CURRENT/smu.FUNC_RESISTANCE
   set_autorange_current: smu.measure.autorange = {}

   # All get parameters
   get_read:  print(smu.measure.read())
   get_read_current:  print(smu.measure.read())
   get_current_read:  print(smu.measure.read())

   # All reset device parameters
   reset:
      - measurement_function: smu.FUNC_DC_CURRENT
      - current_compliance: 2e-6
      - autorange: smu.ON
      - autozero: smu.ON
      - measurement_count: 1
      - filter_enable: smu.ON

   # Misc parameters
   clear_errors: errorqueue.clear()
   exit_script: exit()
   device_IDN_query: "*IDN?"
   reset_device: ["*rst", "*cls"]
   separator: "," # The separator if queued commands are allowed

In principal you have four different sections in a device file:

   * **Set Parameters**
   * **Get Parameters**
   * **Reset Parameters**
   * **Misc. Parameters**

COMET has the feature to run an initialization proceedure over a device, when the software boots up. In order to use
this feature a format has to be considered for the keys in the dictionary.

If a key has the prefix ``default_`` it will be executed during initialization. If the additional prefix ``imp:`` is stated
then this command will be executed before all other commands. Each ``default_`` needs to have a ``set_`` value to work (but not the other way round).
Out of both a command will be build.

Lets see an example to clarify. Imagine you want to initialize the instrument with voltage 0: ::

    {
        "set_voltage": "SOUR:VOLT:LEV ",
        "default_voltage": "0"
    }

The command which will be send to the device will be *SOUR:VOLT:LEV 0*.

.. note:: If you add the item ``"<alias_name>": "<Display_name>"`` to your *defaults.yml* file you can rename the device internally, think of it like a internal, consistent notation.

Now that you have added all crucial commands for a device save it and restart UniDAQ, the result should look like

.. image:: pictures/UniDAQ_resources.png
   :alt: UniDAQ
   :class: floatingflask

.. note:: If you want a more detailed example, there is a full device configuration for a Keithley 2410 SMU in the templates folder.

In a very short time we have achieved a lot, woudn' ya say? You now can add as many GUI elements and devices as you want and also add
the logic to it.

I would recommend to keep the code you have written now. It may come handy to know what and how many devices are defined/connected
to the framework.

Furthermore, I would recommend to add further GUI elements from the repo, especially the "Data_Browser" will come in handy.
With it you can browse all yml files (and more) you have just created. Furthermore, you can manipulate, add and save the data
easily.

Add a new measurement
----------------------------

In this final tutorial I will show you how to add a measurement plugin as easily as the GUI plugins from the previous section.
In order to not program a full GUI, please add the GUI elements **Main_window.py** as shown in the previous tutorials.

First you need to implement a "Project", this can be done if you open a new directory in ``.init/Pad_files``, where
the directory name resembles a "Project". If you have downloaded the turorial branch, then there should be a project already in there.
In this project you find a txt file, which resembles a pad file. Such a file includes information about a specific sensor. In this case a
strip sensor. If you do not include xyz coordinates, such a file can be used as header information file, instead of an strip file.

For completeness reasons I show you now such a pad file and how it generally looks like ::

   # This pad file is for the HPK irradiation sensor for the 6inch runs

   Campaign: Hamamatsu 6inch Irradiation
   Creator: Dominic Bloech 17.07.2018

   reference pad: 1
   reference pad: 32
   reference pad: 64

   # Additional parameters
   implant_length: 20036
   metal_width: 35
   implant_width: 22
   metal_length: 19332.35
   pitch: 90
   thickness: 240
   type: p-type

   strip	x	y	z
   1	    0	0	0
   2	    0	90	0
   3	    0	180	0
   4	    0	270	0
   5	    0	360	0
   6	    0	450	0
   7	    0	540	0
   8	    0  	630	0
   9	    0	720	0
   10	    0	810	0
   11	    0	900	0
   12	    0	990	0
   13	    0	1080	0
   14	    0	1170	0

In order for them to work you have to add a few items into the **defaults.yml** file, so please add ::

   Operator:
      - Your Name

   Projects: # The project names of your sensor batches etc. musst be conform with the sensors entries
        - Test Project

   Sensor_types: # Different sensor types in the various projects
       Test Project:
            - Irradiation

   measurement_types: # If this is prevalent, measurements can be added, these are the objects in which the measurement data can be stored.
      - IV

With this you should be able to start UniDAQ again. (All these parameters are included in the tutorials default file)

.. warning:: Since we have only a fracture of the original program loaded, the program can experience some instabilities and crashes. Especially all table controls are susceptiple! So do not touch them, yet.

Now comming to the fun part. Coding the actual measurement proceedure for a IV curve.
Like it was with the other parts of this tutorial, adding a new measurement can be done via plugins.
Simply add a <name_of_your_measurement>.py file into the folder ``~/UniDAQ/measurement_plugins`` and the program knows this measurement.

A simple IV measurement plugin can already be found in this folder.

.. code-block:: python
   :linenos:

   # This file conducts a simple IV measurement

   import logging
   import sys
   import numpy as np
   sys.path.append('../UniDAQ')
   from ..VisaConnectWizard import *
   from ..utilities import *
   l = logging.getLogger(__name__)

   help = help_functions()
   vcw = VisaConnectWizard.VisaConnectWizard()

   @help.timeit # Decorator for timing of a function (not crucial)
   class IV_class: # Every measurement muss have a class named after the file AND the suffix '_class'

       def __init__(self, main_class):
           # Here all parameters can be definde, which are crucial for the module to work, you can add as much as you want
           self.main = main_class # Import the main parameters and functions
           self.justlength = 24 # paramerter for the writting to file
           time = self.do_IV() # Starts the measurement

       def stop_everything(self):
           """Stops the measurement, by sending a signal to the main loop, via a queue object"""
           order = {"ABORT_MEASUREMENT": True}
           self.main.queue_to_main.put(order)

       @help.timeit
       def do_IVCV(self):
           '''This function conducts an IV measurements'''
           voltage_End = None
           voltage_Start = None
           voltage_steps = None
           bias_SMU = self.main.devices["IVSMU"]

           # Defining the min/max/steps for the meausrement
           voltage_End.append(self.main.job_details["IV"].get("EndVolt", 0))
           voltage_Start.append(self.main.job_details["IV"].get("StartVolt", 0))
           voltage_steps.append(self.main.job_details["IV"].get("Steps", 0))

           # Add the fileheader
           if self.main.save_data:
               self.main.write(self.main.measurement_files["IV"], self.main.job_details["IV"]["header"] + "\n") # writes correctly the units into the file

           # Generates a voltagestep list
           voltage_step_list = self.main.ramp_value(voltage_Start, voltage_End, voltage_steps)

           # Config the setup for IV
           complience = str(self.main.job_details["IV"].get("Complience", "50e-6"))
           self.main.config_setup(bias_SMU, [("set_complience_current", complience)])
           self.main.change_value(bias_SMU, "set_output", "1")

           # Loop over all voltages which should be conducted
           for i, voltage in enumerate(voltage_step_list):
               if not self.main.stop_measurement(): # To shut down if necessary
                   self.main.change_value(bias_SMU, "set_voltage", str(voltage))
                   self.main.settings["Defaults"]["bias_voltage"] = voltage  # changes the bias voltage in the state machine
                   if not self.main.steady_state_check(bias_SMU, max_slope = 1e-6, wait = 0, samples = 5, Rsq = 0.5, complience=complience): # Is a dynamic waiting time for the measuremnts
                       self.stop_everything()

                   if self.main.check_complience(bias_SMU, float(complience)):
                       self.stop_everything() # stops the measurement if complience is reached

                   string_to_write = ""
                   I, V = self.do_IV(voltage, bias_SMU, samples = 3)
                   if self.main.save_data:
                       string_to_write += str(I).ljust(self.justlength) + str(V).ljust(self.justlength)

                   self.main.write(self.main.measurement_files["IVCV"], string_to_write + "\n")  # writes correctly the units into the fileself.main.IVCV_file, string_to_write)

               elif self.main.stop_measurement(): # Stops the measurement if necessary
                   break

           if self.main.save_data: # Closes the file after completion of measurement or abortion
               help.close_file(self.main.IVCV_file)

           # After the measurement ramp down and switch of the SMU
           self.main.ramp_voltage(bias_SMU, "set_voltage", str(voltage_step_list[i-1]), 0, 20, 0.01)
           self.main.change_value(bias_SMU, "set_voltage", "0")
           self.main.change_value(bias_SMU, "set_output", "0")

           return None

       #@help.timeit
       def do_IV(self, voltage, device_dict, samples = 5):
           '''This function simply sends a request for reading a current value and process the data'''
           if not self.main.stop_measurement():
               if not self.main.steady_state_check(device_dict, max_slope=1e-6, wait=0, samples=4,Rsq=0.5, complience=self.main.job_details["IVCV"]["IV"]["Complience"]):  # Is a dynamic waiting time for the measuremnt
                   self.stop_everything()
                   l.warning("Steady state could not be reached, shutdown of measurement")
                   return
               values = []
               for i in range(samples):
                   command = self.main.build_command(device_dict, "get_Read") # returns 2 values!!!
                   values.append(str(vcw.query(device_dict, command)).split("\t"))

               current = sum([float(x[0]) for x in values])/len(values) # Makes a mean out of it
               voltage = sum([float(x[1]) for x in values]) / len(values)  # Makes a mean out of it

               self.main.settings["Defaults"]["bias_voltage"] = voltage  # changes the bias voltage of the sate machine

               self.main.measurement_data["IV"][0] = np.append(self.main.measurement_data["IV"][0], [float(voltage)])
               self.main.measurement_data["IV"][1] = np.append(self.main.measurement_data["IV"][1],[float(current)])
               self.main.queue_to_main.put({"IV": [float(voltage), float(current)]})

               return (current, voltage)

.. note:: The mechanics and functions behind the actual measurement procedure is quiet big. Therefore, I will only talk about the here programmed example but note that the framework gives you a ton of functions to work with for measurement algorithm development. Please see for the deticated tutorial on that.

So lets go through this program in detail:

.. code-block:: python

   import logging
   import sys
   import numpy as np
   sys.path.append('../UniDAQ')
   from ..VisaConnectWizard import *
   from ..utilities import *
   l = logging.getLogger(__name__)

   help = help_functions()
   vcw = VisaConnectWizard.VisaConnectWizard()

   @help.timeit # Decorator for timing of a function (not crucial)
   class IV_class: # Every measurement muss have a class named after the file AND the suffix '_class'

Here basic modules are loaded, you are not restricted to them. You can add and remove as much as you like.

.. code-block:: python

   @help.timeit # Decorator for timing of a function (not crucial)
   class IV_class: # Every measurement muss have a class named after the file AND the suffix '_class'

Here the measurement class is initialized. It is important, that the class declaration has the same name as the file
plus the suffix ``_class``. So, lets say you want the measurement **stripscan**. Just generate a python file with name
``stripscan.py`` and declare the class

.. code-block:: python

   class stripscan_class:

.. code-block:: python

   def __init__(self, main_class):
       # Here all parameters can be definde, which are crucial for the module to work, you can add as much as you want
       self.main = main_class # Import the main parameters and functions
       self.justlength = 24 # paramerter for the writting to file
       time = self.do_IV() # Starts the measurement

Here the init function of the class is defined. Make sure the init function does all the work, so when the interpreter jumps
out of the module, the desired measurement was conducted.

.. code-block:: python

   def stop_everything(self):
      """Stops the measurement, by sending a signal to the main loop, via a queue object"""
      order = {"ABORT_MEASUREMENT": True}
      self.main.queue_to_main.put(order)

This function is a message function to the main loop of the framework. If you put the on the ``queue_to_main``. This message
will be interpreted by the framework as a deep core directive/message. There are a lot of different messages you can send
see the chapter about **data exchange** in the Framework for that.

.. code-block:: python

   @help.timeit
    def do_IVMain(self):
        '''This function conducts an IV measurements'''
        voltage_End = None
        voltage_Start = None
        voltage_steps = None
        bias_SMU = self.main.devices["IVSMU"]

        # Defining the min/max/steps for the meausrement
        voltage_End.append(self.main.job_details["IV"].get("EndVolt", 0))
        voltage_Start.append(self.main.job_details["IV"].get("StartVolt", 0))
        voltage_steps.append(self.main.job_details["IV"].get("Steps", 0))

        # Add the fileheader
        if self.main.save_data:
            self.main.write(self.main.measurement_files["IV"], self.main.job_details["IV"]["header"] + "\n") # writes correctly the units into the file

        # Generates a voltagestep list
        voltage_step_list = self.main.ramp_value(voltage_Start, voltage_End, voltage_steps)

        # Config the setup for IV
        complience = str(self.main.job_details["IV"].get("Complience", "50e-6"))
        self.main.config_setup(bias_SMU, [("set_complience_current", complience)])
        self.main.change_value(bias_SMU, "set_output", "1")

        # Loop over all voltages which should be conducted
        for i, voltage in enumerate(voltage_step_list):
            if not self.main.stop_measurement(): # To shut down if necessary
                self.main.change_value(bias_SMU, "set_voltage", str(voltage))
                self.main.settings["Defaults"]["bias_voltage"] = voltage  # changes the bias voltage in the state machine
                if not self.main.steady_state_check(bias_SMU, max_slope = 1e-6, wait = 0, samples = 5, Rsq = 0.5, complience=complience): # Is a dynamic waiting time for the measuremnts
                    self.stop_everything()

                if self.main.check_complience(bias_SMU, float(complience)):
                    self.stop_everything() # stops the measurement if complience is reached

                string_to_write = ""
                I, V = self.do_IV(voltage, bias_SMU, samples = 3)
                if self.main.save_data:
                    string_to_write += str(I).ljust(self.justlength) + str(V).ljust(self.justlength)

                self.main.write(self.main.measurement_files["IVCV"], string_to_write + "\n")  # writes correctly the units into the fileself.main.IVCV_file, string_to_write)

            elif self.main.stop_measurement(): # Stops the measurement if necessary
                break

        if self.main.save_data: # Closes the file after completion of measurement or abortion
            help.close_file(self.main.IVCV_file)

        # After the measurement ramp down and switch of the SMU
        self.main.ramp_voltage(bias_SMU, "set_voltage", str(voltage_step_list[i-1]), 0, 20, 0.01)
        self.main.change_value(bias_SMU, "set_voltage", "0")
        self.main.change_value(bias_SMU, "set_output", "0")

        return None

Here the actual background tasks for the IV curve are programmed. It shouldn't be hard to decifer it, to understand howe it works.

One important part is the object ``self.main.job_details``. This object contains all information about the sended job from the main framework.
Think of it as a cook recipe for your measurement.

.. warning:: The ``self.main.job_details`` has no fixed size or naming. The content should follow basic rules described in the **measurement generation** topic, though.

.. code-block:: python

   # Add the fileheader
   if self.main.save_data:
       self.main.write(self.main)

Here the header will be written to a file, if you specified the option (default).

.. code-block:: python

   # Generates a voltagestep list
   voltage_step_list = self.main.ramp_value(voltage_Start, voltage_End, voltage_steps)

Now coming to one of the most important parts of the framework. The framework gives you a ton of build in functions and variables to work with.
All of them can be accessed via the object ``self.main`` (if correctly stated in the init function).
These functions can be used to automatise some task, which are usually need by a user. One of these functions is ``ramp_value``.
This function takes a start, end and step value and returns you a list, of values.

.. note:: For more information on these functions and how they work, see the reference manual or the corresponding topic in this doc.

.. code-block:: python

   def do_IV(self, voltage, device_dict, samples = 5):
           '''This function simply sends a request for reading a current value and process the data'''
           if not self.main.stop_measurement():
               if not self.main.steady_state_check(device_dict, max_slope=1e-6, wait=0, samples=4,Rsq=0.5, complience=self.main.job_details["IVCV"]["IV"]["Complience"]):  # Is a dynamic waiting time for the measuremnt
                   self.stop_everything()
                   l.warning("Steady state could not be reached, shutdown of measurement")
                   return
               values = []
               for i in range(samples):
                   command = self.main.build_command(device_dict, "Read") # returns 2 values!!!
                   values.append(str(vcw.query(device_dict, command)).split("\t"))

               current = sum([float(x[0]) for x in values])/len(values) # Makes a mean out of it
               voltage = sum([float(x[1]) for x in values]) / len(values)  # Makes a mean out of it

               self.main.settings["Defaults"]["bias_voltage"] = voltage  # changes the bias voltage of the sate machine

               self.main.measurement_data["IV"][0] = np.append(self.main.measurement_data["IV"][0], [float(voltage)])
               self.main.measurement_data["IV"][1] = np.append(self.main.measurement_data["IV"][1],[float(current)])
               self.main.queue_to_main.put({"IV": [float(voltage), float(current)]})

               return (current, voltage)

Here the loop over the voltage list is conducted, using build-in functions from the framework.
The only interesting part is, when it calls the ``do_IV(...)`` function. The purpose of this function is to simply accuire a value
from a device. Here an algorithm was used to mitigate noise effects. Furthermore, the aquiered data is put in objects provided by the framework
to safely store the measured data, even if the script is crashing (``self.main.measurement_data["IV"]``).

.. warning:: This automated storage generation will only work, if you have stated the measurement in the defaults file under the parameter ``measurement_types``.
