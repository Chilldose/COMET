"""This script plots IVCV files together for files generated by QTC
Data must be """

import logging, os
import holoviews as hv
from holoviews import opts
from scipy.stats import linregress
from copy import deepcopy
import pandas as pd
import numpy as np
hv.extension('bokeh', 'matplotlib')

from bokeh.models import CustomJS
from bokeh.models.widgets import Button

from forge.tools import customize_plot, holoplot, convert_to_df, config_layout
from forge.tools import twiny, relabelPlot
from forge.tools import plot_all_measurements, convert_to_EngUnits
from forge.specialPlots import dospecialPlots
from forge.utilities import line_intersection


class IVCV_QTC:

    def __init__(self, data, configs):

        self.log = logging.getLogger(__name__)
        self.data = convert_to_df(data, abs=True)
        self.config = configs
        self.df = []
        self.basePlots = None
        self.PlotDict = {"Name": "IVCV"}
        self.capincluded = False
        if "capacitance" in self.data[self.data["keys"][0]]["data"]:
            self.data["columns"].insert(3,"1C2") # because we are adding it later on
            self.capincluded = True
        self.measurements = self.data["columns"]
        self.xaxis = self.measurements[0]

        if "voltage" in self.measurements:
            self.xaxis = "voltage"
            padidx = self.measurements.index("voltage")
            del self.measurements[padidx]

        # Convert the units to the desired ones
        for meas in self.measurements:
            unit = self.config["IVCV_QTC"].get(meas, {}).get("UnitConversion", None)
            if unit:
                self.data = convert_to_EngUnits(self.data, meas, unit)

        hv.renderer('bokeh')

    def run(self):
        """Runs the script"""

        # Add the 1/c^2 data to the dataframes
        for df in self.data["keys"]:
            if "capacitance" in self.data[df]["data"]:
                self.data[df]["data"].insert(3, "1C2", 1 / self.data[df]["data"]["capacitance"].pow(2))
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("1C2")

        # Add the measurement to the list

        # Plot all Measurements
        self.basePlots = plot_all_measurements(self.data, self.config, self.xaxis, "IVCV_QTC", do_not_plot=("voltage", "voltage_1"))
        self.PlotDict["BasePlots"] = self.basePlots
        self.PlotDict["All"] = self.basePlots

        # Add full depletion point to 1/c^2 curve
        try:
            c2plot = self.basePlots.Overlay.CV_CURVES_hyphen_minus_Full_depletion
            self.basePlots.Overlay.CV_CURVES_hyphen_minus_Full_depletion = self.find_full_depletion(c2plot, self.data, self.config)
        except Exception as err:
            self.log.warning("No full depletion calculation possible... Error: {}".format(err))

        # Whiskers Plot
        self.WhiskerPlots = dospecialPlots(self.data, self.config, "IVCV_QTC", "BoxWhisker", self.measurements)
        if self.WhiskerPlots:
            self.PlotDict["Whiskers"] = self.WhiskerPlots
            self.PlotDict["All"] = self.PlotDict["All"] + self.WhiskerPlots

        # Reconfig the plots to be sure
        self.PlotDict["All"] = config_layout(self.PlotDict["All"], **self.config["IVCV_QTC"].get("Layout", {}))

        # Add the download button for all data
        #button = Button(label="Download", button_type="success")
        #button.callback = CustomJS(args=dict(source=self.data),
        #                           code=open(os.path.join(os.path.dirname(__file__), "download.js")).read())
        #self.PlotDict["All"] += button
        #self.PlotDict["download"] = button
        return self.PlotDict


    def find_full_depletion(self, plot, data, configs, **addConfigs):
        """
        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the
        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.
        :param plot: The plot object
        :param data: The data files
        :param configs: the configs
        :param **addConfigs: the configs special for the 1/C2 plot, it is recomended to pass the same options here again, like in the original plot!
        :return: The updated plot
        """

        full_depletion_voltages = np.zeros((len(data["keys"]), 2))
        Left_stats = np.zeros((len(data["keys"]), 6), dtype=np.object)
        Right_stats = np.zeros((len(data["keys"]), 6), dtype=np.object)
        self.log.info("Searching for full depletion voltage in all files...")

        for i, samplekey in enumerate(data["keys"]):
            if "1C2" not in data[samplekey]["data"]:
                self.log.warning("Full depletion calculation could not be done for data set: {}".format(samplekey))

            else:
                self.log.debug("Data: {}".format(samplekey))
                sample = deepcopy(data[samplekey])
                try:
                    df = pd.DataFrame({"xaxis": sample["data"]["voltage"], "yaxis": sample["data"]["1C2"]})
                except:
                    df = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["1C2"]})
                df = df.dropna()


                # Loop one time from the right side and from the left, to get both slopes
                LR2 = 0 # r^2 values for both sides
                RR2 = 0


                for idx in range(5, len(df)-5):
                    # Left
                    slope_left, intercept_left, r_left, p_value, std_err_left = linregress(df["xaxis"][:-idx],df["yaxis"][:-idx])
                    r2_left = r_left * r_left
                    self.log.debug("Left side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                        slope_left, intercept_left, r2_left, std_err_left)
                    )

                    # Right
                    slope_right, intercept_right, r_right, p_value, std_err_right = linregress(df["xaxis"][idx:],df["yaxis"][idx:])
                    r2_right = r_right * r_right
                    self.log.debug("Right side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                        slope_right, intercept_right, r2_right, std_err_right)
                    )

                    # See if the r2 value has increased and store end points
                    if r2_left >= LR2:
                        LR2 = r2_left
                        LeftEndPoints = (
                            (df["xaxis"][0], intercept_left),
                            (df["xaxis"][idx], slope_left * df["xaxis"][idx] + intercept_left)
                        )
                        Left_stats[i] = (LeftEndPoints, slope_left, intercept_left, r_left, p_value, std_err_left)

                    # See if the r2 value has increased and store it
                    if r2_right >= RR2:
                        RR2 = r2_right
                        RightEndPoints = (
                            (df["xaxis"][idx], slope_right * df["xaxis"][idx] + intercept_right),
                            (df["xaxis"][len(df["xaxis"]) - 1], slope_right * df["xaxis"][len(df["xaxis"]) - 1] + intercept_right),
                        )
                        Right_stats[i] = (RightEndPoints, slope_right, intercept_right, r_right, p_value, std_err_right)

                # Make the line intersection
                full_depletion_voltages[i] = line_intersection(LeftEndPoints, RightEndPoints)

        # Add vertical line for full depletion
        # Find nonzero indizes
        valid_indz = np.nonzero(full_depletion_voltages[:, 0])
        vline = hv.VLine(np.median(full_depletion_voltages[valid_indz], axis=0)[0]).opts(color='black', line_width=5.0)

        # Add slopes
        xmax = df["xaxis"][len(df["yaxis"])-1]
        left_line = np.array([[0, np.median(Left_stats[:,2])],[xmax, np.median(Left_stats[:,1])*xmax + np.median(Left_stats[:,2])]])
        left_line = hv.Curve(left_line).opts(color='grey')

        right_line = np.array([[0, np.median(Right_stats[:,2])],[xmax, np.median(Right_stats[:,1])*xmax + np.median(Right_stats[:,2])]])
        right_line = hv.Curve(right_line).opts(color='grey')

        # Add text
        self.log.info('Full depletion voltage: {} V, '
                        'Error: {} V'.format(np.round(np.median(full_depletion_voltages[valid_indz, 0]), 2),
                                           np.round(np.std(full_depletion_voltages[valid_indz, 0]), 2)))
        text = hv.Text(700, 0.055, 'Depletion voltage: {} V \n'
                        'Error: {} V'.format(np.round(np.median(full_depletion_voltages[:, 0]), 2),
                                           np.round(np.std(full_depletion_voltages[valid_indz, 0]), 2))
                       ).opts(fontsize=30)


        # Update the plot specific options if need be
        returnPlot = plot * vline * right_line * left_line * text
        returnPlot = customize_plot(returnPlot, "1C2", configs["IVCV_QTC"], **addConfigs)

        return returnPlot