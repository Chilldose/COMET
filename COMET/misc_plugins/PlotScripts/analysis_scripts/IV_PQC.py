"""This script plots IVCV files together for files generated by QTC
Data must be """

import logging, os
import holoviews as hv
from holoviews import opts
from scipy.stats import linregress
from copy import deepcopy

import pandas as pd
import numpy as np
hv.extension('bokeh', 'matplotlib')

from forge.tools import customize_plot, holoplot, convert_to_df, config_layout, applyPlotOptions
from forge.tools import twiny, relabelPlot
from forge.tools import plot_all_measurements, convert_to_EngUnits
from forge.specialPlots import dospecialPlots
from forge.utilities import line_intersection


class IV_PQC:

    def __init__(self, data, configs):

        self.log = logging.getLogger(__name__)
        self.data = convert_to_df(data, abs=False, keys="all")
        self.config = configs
        self.df = []
        self.basePlots = None
        self.basePlots_2 = None
        self.name = "IV_PQC"
        self.PlotDict = {"Name": "IV"}
        self.capincluded = False

        # add a copy of Capacity and first and second derivatives to the data

        if "Capacity" in self.data[self.data["keys"][0]]["data"]:
            self.data["columns"].insert(3, "CapacityCopy")
            self.data["columns"].insert(4, "derivative")
            self.data["columns"].insert(5, "derivative2")
            self.data["columns"].insert(6, "1C2")
            self.data["columns"].insert(7,"derivative1C2")
            self.data["columns"].insert(8, "x")
            self.data["columns"].insert(9, "N")
            self.capincluded = True




        self.measurements = self.data["columns"]
        self.xaxis = self.measurements[0]
        self.donts = ["timestamp", "voltage","current","Voltage","Stepsize","Wait","Stepsize","Frequency",'x','N']
        hv.renderer('bokeh')



        # Convert the units to the desired ones
        for meas in self.measurements:
            unit = self.config[self.name].get(meas, {}).get("UnitConversion", None)
            if unit:
                self.data = convert_to_EngUnits(self.data, meas, unit)



    def run(self):
        """Runs the script"""

        # Add the 1/c^2 data to the dataframes
        # Add a copy of the Capacity values to the data frame, where the small kink in the plot is deleted
        for df in self.data["keys"]:

            if "Capacity" in self.data[df]["data"]:
                if not self.data['keys'][0][0:8] == 'CV_Diode' or self.data['keys'][0][0:5] == 'IV_GCD':
                    if 'Voltage' in self.data[df]['data']: # Check that the voltage values have increasing order
                        if self.data[df]["data"]["Voltage"][0] > 0:
                            self.data[df]["data"]["Voltage"] = list(reversed(self.data[df]["data"]["Voltage"]))
                            self.data[df]["data"]["Capacity"] = list(reversed(self.data[df]["data"]["Capacity"]))
                    self.data[df]["data"]["Capacity"] = self.data[df]["data"]["Capacity"] / (float(self.data[df]['header'][0].split(':')[1])*(1e-8)) # Normalize by the Area and convert to cm^2
                    CapacityCopy = self.data[df]["data"]["Capacity"].copy()
                    capMin= np.max(self.data[df]["data"]["Capacity"][:20]) # Find the Maximum among te first 20 values of the Capacity and set it as minimum Capacity value
                    for x in range(len(self.data[df]["data"]["Capacity"])):
                        if CapacityCopy[x] < capMin:
                            CapacityCopy[x] = capMin
                    # insert into the data frame
                    self.data[df]["data"].insert(3, "CapacityCopy", CapacityCopy)
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("CapacityCopy")


                    dy1 = np.diff(self.data[df]["data"][
                                      "CapacityCopy"])  # compute the difference between each consecutive Capacity value and store it into an array with length i-1
                    dx1 = np.diff(self.data[df]["data"][
                                      self.xaxis])  # compute the difference between each consecutive voltage value and store it into an array with length i-1
                    der1 = dy1 / dx1
                    firstdev = np.insert(der1, 0, der1[
                        0])  # Add an element to the array to have the same number of rows as in df
                    dy2 = np.diff(self.data[df]["data"]["CapacityCopy"],
                                  n=2)  # n=2 applies diff() two times to compute the second derivative, dy2 is of lenght i-2
                    dy2_2 = np.insert(dy2, 0, dy2[0])  # add one element to dy2 to have the same length of dx1
                    der2 = dy2_2 / dx1
                    seconddev = np.insert(der2, 0, der2[
                        0])  # Add one element to the array to have the same number of rows as in df
                    # insert first derivative into dataframe
                    self.data[df]["data"].insert(4, "derivative", firstdev)
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("derivative")
                    # insert second derivative into dataframe
                    self.data[df]["data"].insert(5, "derivative2", seconddev)
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("derivative2")
                    ## Find the index of the row which contains the maximum value of the second derivative
                    indexMax = self.data[df]['data'].index.get_loc(
                        self.data[df]['data']['derivative2'].values.argmax())
                    ## Find the index of the row which contains the minimum value of the second derivative
                    indexMin = self.data[df]['data'].index.get_loc(
                        self.data[df]['data']['derivative2'].values.argmin())

                elif self.data['keys'][0][0:8] == 'CV_Diode' or self.data['keys'][0][0:5] == 'IV_GCD':

                    if "Capacity" in self.data[df]["data"]:

                        self.data[df]["data"]["Voltage"] = list(map(abs,self.data[df]["data"]["Voltage"]))
                        self.data[df]["data"].insert(3, "1C2", 1 / self.data[df]["data"]["Capacity"].pow(2))
                        self.data[df]["units"].append("arb. units")
                        self.data[df]["measurements"].append("1C2")

                        invers_C2_dy = np.diff(self.data[df]["data"]["1C2"])
                        invers_C2_dx = np.diff(self.data[df]["data"][self.xaxis])
                        der_invers_C2 = invers_C2_dy/invers_C2_dx
                        firstdev_invers_C2 = np.insert(der_invers_C2, 0, der_invers_C2[0])  # Add an element to the array to have the same number of rows as in df
                        self.data[df]["data"].insert(4, "derivative1C2", firstdev_invers_C2)
                        self.data[df]["units"].append("arb. units")
                        self.data[df]["measurements"].append("derivative1C2")

                        x = (self.config['IV_PQC_parameter']['epsilonNull']*(1e-6)* float(self.data[self.data['keys'][0]]['header'][0].split(':')[1]) \
                            * self.config['IV_PQC_parameter']['epsilonSiliconOxide']) / self.data[df]["data"]["Capacity"][:42]
                        self.data[df]['data'].insert(5, 'x', x)
                        self.data[df]["units"].append("arb. units")
                        self.data[df]["measurements"].append("x")

                        N = (2)/(self.config['IV_PQC_parameter']['epsilonNull']*(1e-2) \
                            * self.config['IV_PQC_parameter']['q'] * self.config['IV_PQC_parameter']['epsilonSiliconOxide'] * self.data[df]["data"]["derivative1C2"][:42] \
                                      *(float(self.data[self.data['keys'][0]]['header'][0].split(':')[1])*(1e-8))*(float(self.data[self.data['keys'][0]]['header'][0].split(':')[1])*(1e-8)))
                        self.data[df]['data'].insert(6, 'N', N)
                        self.data[df]["units"].append("arb. units")
                        self.data[df]["measurements"].append("N")

                    # Plot all Measurements
                    self.basePlots = plot_all_measurements(self.data, self.config, self.xaxis, self.name,
                                                           do_not_plot=self.donts)
                    self.PlotDict["BasePlots"] = self.basePlots
                    self.PlotDict["All"] = self.basePlots
                    # Add full depletion point to 1/c^2 curve
                    if self.config["IV_PQC"].get("1C2", {}).get("DoFullDepletionCalculation", False):

                            try:

                                if self.basePlots.Overlay.CV_CURVES_hyphen_minus_Full_depletion.children:

                                    c2plot = self.basePlots.Overlay.CV_CURVES_hyphen_minus_Full_depletion.opts(
                                        clone=True)

                                else:
                                    c2plot = self.basePlots.Curve.CV_CURVES_hyphen_minus_Full_depletion.opts(clone=True)

                                fdestimation = self.find_full_depletion_c2(c2plot, self.data, self.config,
                                                                           PlotLabel="Full depletion estimation")

                                self.PlotDict["All"] += fdestimation

                                self.PlotDict["BasePlots"] += fdestimation

                            except Exception as err:

                                self.log.warning("No full depletion calculation possible... Error: {}".format(err))


        fbvoltage = []
        Accum_capacitance = []
        Accum_capacitance_normalized = []
        Tox = []
        Nox = []
        # Add the first and second derivative data to the dataframes
        for df in self.data["keys"]:



            if "Current" in self.data[df]["data"]:
                mxx = max(self.data[df]['data']['Current'])
                min = np.mean(self.data[df]['data']['Current'][-20:])
                Isurf = mxx - min

                text = hv.Text(0, 9*(1e-11), 'Isurf: {} A'.format(
                    np.round(Isurf, 15)),


                           ).opts(style=dict(text_font_size='25pt'))


            # Plot all Measurements
            self.basePlots = plot_all_measurements(self.data, self.config, self.xaxis, self.name,
                                                   do_not_plot=self.donts)
            self.PlotDict["BasePlots"] = self.basePlots #*text
            self.PlotDict["All"] = self.basePlots #*text
            if 'x' in self.data[df]["data"]:
                # Add plot with a different x axis
                self.basePlots_2 = plot_all_measurements(self.data, self.config, 'x', self.name,
                                                         do_not_plot=['Voltage', 'Current', 'Capacity', '1C2',
                                                                      'derivative1C2', 'x'])
                self.PlotDict["BasePlots"] += self.basePlots_2
                self.PlotDict["All"] += self.basePlots_2

            # Add flat bandage voltage point to the Capacity curve
            if self.config["IV_PQC"].get("CapacityCopy", {}).get("findFlatBandVoltage", False):
                    try:
                        if self.basePlots.Overlay.MOS_CV_CURVES.children:
                            clone_plot = self.basePlots.Overlay.MOS_CV_CURVES.opts(clone=True)

                        else:
                            clone_plot = self.basePlots.Curve.MOS_CV_CURVES.opts(clone=True)

                        fBestimation = self.find_flatBand_voltage(clone_plot, self.data, self.config, indexMax,
                                                                  indexMin,
                                                                  PlotLabel="Flat band voltage estimation")

                        fbvoltage += fBestimation[1][0]
                        Accum_capacitance += fBestimation[2]
                        Accum_capacitance_normalized += fBestimation[3]
                        Tox += fBestimation[4]
                        Nox += fBestimation[5]

                        self.PlotDict["All"] += fBestimation[0]
                        self.PlotDict["BasePlots"] += fBestimation[0]

                    except Exception as err:
                        self.log.warning("No flat band voltage calculation possible... Error: {}".format(err))





        self.PlotDict["All"] = applyPlotOptions(self.PlotDict["All"], {'Curve': {'color': "hv.Cycle('PiYG')"}})




        # Add table
        for df in self.data["keys"]:
            table = hv.Table(self.data[df]['data'], ['Name', 'Voltage'], group=df)
            table.opts(width=1300, height=800)
            self.PlotDict["All"] += table
            self.PlotDict["BasePlots"] += table

        #df2 = pd.DataFrame({"Name": self.data['keys'], "fbVoltage": fbvoltage, 'Accum_capacitance'=Accum_capacitance,'Accum_capacitance_normalized'=Accum_capacitance_normalized,'Tox'=Tox,'Nox'=Nox})
        #table1=hv.Table(df2)
        #self.PlotDict["All"] += table1
        #self.PlotDict["BasePlots"] += table1

        # Reconfig the plots to be sure
        self.PlotDict["All"] = config_layout(self.PlotDict["All"], **self.config[self.name].get("Layout", {}))
        return self.PlotDict

    def find_flatBand_voltage(self, plot, data, configs, indexMax, indexMin, **addConfigs):
        """
        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the
        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.
        :param plot: The plot object
        :param data: The data files
        :param configs: the configs
        :param **addConfigs: the configs special for the 1/C2 plot, it is recommended to pass the same options here again, like in the original plot!
        :return: The updated plot
        """
        flatband_voltage = np.zeros((len(data["keys"]), 2))
        Right_stats = np.zeros((len(data["keys"]), 6), dtype=np.object)
        fit_stats = np.zeros((len(data["keys"]), 6), dtype=np.object)
        self.log.info("Searching for flat band voltage voltage in all files...")

        for i, samplekey in enumerate(data["keys"]):
            if "CapacityCopy" not in data[samplekey]["data"]:
                self.log.warning("Flat band voltage calculation could not be done for data set: {}".format(samplekey))

            else:
                self.log.debug("Data: {}".format(samplekey))
                sample = deepcopy(data[samplekey])
                try:
                    df = pd.DataFrame({"xaxis": sample["data"]["voltage"], "yaxis": sample["data"]["CapacityCopy"]})
                except:
                    df = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["CapacityCopy"]})
                df = df.dropna()


                # Loop one time from the right side, to get the slope of the accumulation region, and then loop on the fit region to get the fit slope
                RR2 = 0
                fitR2 = 0

                for idx in range(5, len(df)-5):
                    # Right
                    slope_right, intercept_right, r_right, p_value, std_err_right = linregress(df["xaxis"][idx:],df["yaxis"][idx:])
                    r2_right = r_right * r_right
                    self.log.debug("Right side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                        slope_right, intercept_right, r2_right, std_err_right)
                    )

                    # See if the r2 value has increased and store it
                    if r2_right >= RR2:
                        RR2 = r2_right
                        RightEndPoints = (
                            (df["xaxis"][idx], slope_right * df["xaxis"][idx] + intercept_right),
                            (df["xaxis"][len(df["xaxis"]) - 1], slope_right * df["xaxis"][len(df["xaxis"]) - 1] + intercept_right),
                        )
                        Right_stats[i] = (RightEndPoints, slope_right, intercept_right, r_right, p_value, std_err_right)



        ## Fit central region

                for idx in range(indexMax, indexMin-2):

                    #Central fit
                    slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit = linregress(df["xaxis"][idx:indexMin-2],
                                                                                          df["yaxis"][idx:indexMin-2])
                    r2_fit = r_fit * r_fit
                    self.log.debug("central fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                        slope_fit, intercept_fit, r2_fit, std_err_fit)
                    )

                    # See if the r2 value has increased and store it
                    if r2_fit >= fitR2:
                        fitR2 = r2_fit
                        fitEndPoints = (
                            (df["xaxis"][indexMax], slope_fit * df["xaxis"][indexMax] + intercept_fit),
                            (df["xaxis"][idx+1], slope_fit * df["xaxis"][idx+1] + intercept_fit) # use idx +1 to avoid having the same end points
                        )
                        fit_stats[i] = (fitEndPoints, slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit)

        # Add central slope
        xmax = df["xaxis"][indexMin]

        fit_line = np.array([[df["xaxis"][indexMax-3], np.median(fit_stats[:, 1]) *df["xaxis"][indexMax-3]  + np.median(fit_stats[:, 2])],
                               [xmax+0.2, np.median(fit_stats[:, 1]) * (xmax+0.2) + np.median(fit_stats[:, 2])]])

        # Add right slope
        xmax = df["xaxis"][len(df["yaxis"]) - 1]
        right_line = np.array([[df["xaxis"][indexMax-3],np.median(Right_stats[:, 1]) *df["xaxis"][indexMax-3] + np.median(Right_stats[:, 2])],
                               [xmax, np.median(Right_stats[:, 1]) * xmax + np.median(Right_stats[:, 2])]])

        # Plots of the fits
        right_line = hv.Curve(right_line).opts(color='blue')
        fit_line = hv.Curve(fit_line).opts(color='red')

        # Compute the flatband voltage
        flatband_voltage[i]=line_intersection(fit_stats[i][0], Right_stats[i][0])


        # Find nonzero indices and add vertical line for full depletion

        valid_indz = np.nonzero(flatband_voltage[:, 0])

        vline = hv.VLine(np.median(flatband_voltage[valid_indz], axis=0)[0]).opts(color='black', line_width=2.0)

        # Plots of the derivatives
        firstDerivativePlot= self.basePlots.Curve.firstderivative
        secondDerivativePlot = self.basePlots.Curve.secondderivative


        # Find oxide thickness Tox in nm
        Accum_capacitance = np.max(df["yaxis"]) * (float(self.data[self.data['keys'][0]]['header'][0].split(':')[1])*(1e-8)) # float(..) is the area. Only valide if only one data file is used
        Accum_capacitance_normalized = np.max(df["yaxis"])  #F/cm^2
        Tox = self.config['IV_PQC_parameter']['epsilonNull'] * self.config['IV_PQC_parameter']['epsilonSiliconOxide'] * 1e+5 / Accum_capacitance_normalized


        # Find Fixed oxide charge Nox in cm^-2
        phi_s = self.config['IV_PQC_parameter']['electronAffinity'] + self.config['IV_PQC_parameter']['bandGapEnergy']/2\
                + (self.config['IV_PQC_parameter']['boltzmannConstant']*self.config['IV_PQC_parameter']['Temperature']
                   *np.log(self.config['IV_PQC_parameter']['SiliconDoping']/self.config['IV_PQC_parameter']['intrinsicDopingConcentration']))/self.config['IV_PQC_parameter']['q']
        phi_ms = self.config['IV_PQC_parameter']['phi_m']-phi_s

        Nox = (Accum_capacitance_normalized*(phi_ms + flatband_voltage[0][0]))/(self.config['IV_PQC_parameter']['q'])

        # Add text
        text = hv.Text(-2.5, 0.00000000065, 'Flat band voltage: {} V \n'
                          
                        'C accumulation: {} F \n'                   

                        'C accumulation/A: {} F/cm\N{SUPERSCRIPT TWO} \n'
        
                       'Tox: {} nm \n'
                       'Nox: {} cm\N{SUPERSCRIPT MINUS}\N{SUPERSCRIPT TWO}'.format(np.round(np.median(flatband_voltage[:, 0]), 2),
                                           np.round(Accum_capacitance,10),
                                           np.round(Accum_capacitance_normalized, 10),
                                           np.round(Tox, 2),
                                           np.format_float_scientific(Nox, 2))

                       ).opts(style=dict(text_font_size='25pt'))


        # Update the plot specific options if need be
        returnPlot =  plot * vline * text  * firstDerivativePlot * right_line * secondDerivativePlot * fit_line
        #returnPlot = relabelPlot(returnPlot, "MOS_CV CURVES - Full depletion calculation")
        #returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)

        return returnPlot, flatband_voltage[:, 0], Accum_capacitance, Accum_capacitance_normalized,Tox, Nox
        #self.basePlots.opts(opts.Curve(color=hv.Cycle('Category20')))

    def find_full_depletion_c2(self, plot, data, configs, **addConfigs):

        """

        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the

        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.

        :param plot: The plot object

        :param data: The data files

        :param configs: the configs

        :param **addConfigs: the configs special for the 1/C2 plot, it is recomended to pass the same options here again, like in the original plot!

        :return: The updated plot

        """



        full_depletion_voltages = np.zeros((len(data["keys"]), 2))

        Left_stats = np.zeros((len(data["keys"]), 6), dtype=np.object)

        Right_stats = np.zeros((len(data["keys"]), 6), dtype=np.object)

        self.log.info("Searching for full depletion voltage in all files...")



        for i, samplekey in enumerate(data["keys"]):

            if "1C2" not in data[samplekey]["data"]:

                self.log.warning("Full depletion calculation could not be done for data set: {}".format(samplekey))



            else:

                self.log.debug("Data: {}".format(samplekey))

                sample = deepcopy(data[samplekey])

                df = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["1C2"]})

                df = df.dropna()





                # Loop one time from the right side and from the left, to get both slopes

                LR2 = 0 # r^2 values for both sides

                RR2 = 0





                for idx in range(5, len(df)-5):

                    # Left

                    slope_left, intercept_left, r_left, p_value, std_err_left = linregress(df["xaxis"][:-idx],df["yaxis"][:-idx])

                    r2_left = r_left * r_left

                    self.log.debug("Left side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(

                        slope_left, intercept_left, r2_left, std_err_left)

                    )



                    # Right

                    slope_right, intercept_right, r_right, p_value, std_err_right = linregress(df["xaxis"][idx:],df["yaxis"][idx:])

                    r2_right = r_right * r_right

                    self.log.debug("Right side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(

                        slope_right, intercept_right, r2_right, std_err_right)

                    )



                    # See if the r2 value has increased and store end points

                    if r2_left >= LR2:

                        LR2 = r2_left

                        LeftEndPoints = (

                            (df["xaxis"][0], intercept_left),

                            (df["xaxis"][idx], slope_left * df["xaxis"][idx] + intercept_left)

                        )

                        Left_stats[i] = (LeftEndPoints, slope_left, intercept_left, r_left, p_value, std_err_left)



                    # See if the r2 value has increased and store it

                    if r2_right >= RR2:

                        RR2 = r2_right

                        RightEndPoints = (

                            (df["xaxis"][idx], slope_right * df["xaxis"][idx] + intercept_right),

                            (df["xaxis"][len(df["xaxis"]) - 1], slope_right * df["xaxis"][len(df["xaxis"]) - 1] + intercept_right),

                        )

                        Right_stats[i] = (RightEndPoints, slope_right, intercept_right, r_right, p_value, std_err_right)



                # Make the line intersection

                full_depletion_voltages[i] = line_intersection(LeftEndPoints, RightEndPoints)



        # Add vertical line for full depletion

        # Find nonzero indizes

        valid_indz = np.nonzero(full_depletion_voltages[:, 0])

        vline = hv.VLine(np.median(full_depletion_voltages[valid_indz], axis=0)[0]).opts(color='black', line_width=5.0)



        # Add slopes

        xmax = df["xaxis"][len(df["yaxis"])-1]

        left_line = np.array([[0, np.median(Left_stats[:,2])],[xmax, np.median(Left_stats[:,1])*xmax + np.median(Left_stats[:,2])]])

        left_line = hv.Curve(left_line).opts(color='grey')



        right_line = np.array([[0, np.median(Right_stats[:,2])],[xmax, np.median(Right_stats[:,1])*xmax + np.median(Right_stats[:,2])]])

        right_line = hv.Curve(right_line).opts(color='grey')



        # Add text

        self.log.info('Full depletion voltage: {} V, '

                        'Error: {} V'.format(np.round(np.median(full_depletion_voltages[valid_indz, 0]), 2),

                                           np.round(np.std(full_depletion_voltages[valid_indz, 0]), 2)))

        text = hv.Text(700, 0.055, 'Depletion voltage: {} V \n'

                        'Error: {} V'.format(np.round(np.median(full_depletion_voltages[:, 0]), 2),

                                           np.round(np.std(full_depletion_voltages[valid_indz, 0]), 2))

                       ).opts(fontsize=30)





        # Update the plot specific options if need be

        returnPlot = plot * vline * right_line * left_line * text

        #returnPlot = relabelPlot(returnPlot, "CV CURVES - Full depletion calculation")

        #returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)



        return returnPlot



