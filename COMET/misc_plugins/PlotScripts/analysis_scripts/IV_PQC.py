"""This script plots IVCV files together for files generated by QTC
Data must be """

import logging, os
import holoviews as hv
#from holoviews import opts
from scipy.stats import linregress
from copy import deepcopy
from scipy.interpolate import interp1d

import pandas as pd
import numpy as np

from forge.tools import customize_plot, holoplot, convert_to_df, config_layout, applyPlotOptions
#from forge.tools import twiny, relabelPlot
from forge.tools import plot_all_measurements, convert_to_EngUnits
#from forge.specialPlots import dospecialPlots
from forge.utilities import line_intersection



class IV_PQC:

    def __init__(self, data, configs):
        if not all(i[0:6] == 'IV_GCD' for i in list(data.keys())):
            i = 0
            while list(data.keys())[0][0:6] == 'IV_GCD':
                data[list(data.keys())[0] + str(i)] = data[list(data.keys())[0]]
                del data[list(data.keys())[0]]
                i += 1
        self.log = logging.getLogger(__name__)
        self.data = convert_to_df(data, abs=False, keys= 'all')
        self.config = configs
        self.df = []
        self.basePlots = None
        self.basePlots_2 = None
        self.name = "IV_PQC"
        self.PlotDict = {"Name": "IV"}
        self.capincluded = False

        # add a copyCapacity, first and second derivatives for the cv_mos anlaysis to the data frame;
        # add a 1/C2, the derivative of 1/C2, add the deep x and the surface doping profile N to the data frame;


        self.data["columns"].insert(3, "CapacityCopy")
        self.data["columns"].insert(4, "derivative")
        self.data["columns"].insert(5, "derivative2")
        self.data["columns"].insert(6, "1C2")
        self.data["columns"].insert(7,"derivative1C2")
        self.data["columns"].insert(8, "x")
        self.data["columns"].insert(9, "N")
        self.data["columns"].insert(10, "firstderivative_gate")
        self.capincluded = True




        self.measurements = self.data["columns"]
        self.xaxis = self.measurements[0]
        self.donts = ["timestamp", "voltage","Voltage","Stepsize","Wait","Stepsize","Frequency",'x','N'] #do not plot this data
        hv.renderer('bokeh')

        # Convert the units to the desired ones
        for meas in self.measurements:
            unit = self.config[self.name].get(meas, {}).get("UnitConversion", None)
            if unit:
                self.data = convert_to_EngUnits(self.data, meas, unit)



    def run(self):
        """Runs the script"""
        fbvoltage = [] #list that is used later on to store the flat band voltage values for all the different files used in the analysis
        Accum_capacitance = [] #list that is used later on to store the accumulation capacitance values for all the different files used in the analysis
        Accum_capacitance_normalized = [] #list that is used later on to store the area-normalized accumulation capacitance values for all the different files used in the analysis
        Tox = [] #list that is used later on to store the oxide thickness values for all the different files used in the analysis
        Nox = [] #list that is used later on to store the oxide charge values for all the different files used in the analysis
        fdepvoltage = [] #list that is used later on to store the full depletion  voltage values for all the different files used in the analysis
        count = 0
        count2 = 0
        count3 = 0
        diode = [] #list that is used later on to store all the files used in the diode analysis
        cv = [] #list that is used later on to store all the files used in the mos analysis
        gate = [] #list that is used later on to store all the files used in the gate analysis
        Surface_current = [] #list that is used later on to store the surface current values for all the different gate files used in the analysis
        Surface_recombination_velocity = [] #list that is used later on to store the surface recombination velocity values for all the different gate files used in the analysis
        Surface_current_average = [] #list that is used later on to store the surface current values for all the different gate files used in the analysis
        Surface_recombination_velocity_average = [] #list that is used later on to store the surface recombination velocity values for all the different gate files used in the analysis

        # Add the 1/c^2 data to the dataframes
        # Add a copy of the Capacity values to the data frame, where the small kink in the plot is deleted
        for df in self.data["keys"]:

            # Start the cv_mos analysis
            if df[0:8] != 'CV_Diode' and df[0:6] != 'IV_GCD': #If not Diode or Gate analysis do the cv mos analysis
                cv.append(df)
                if 'Voltage' in self.data[df]['data']: # Check that the voltage values have increasing order
                    if self.data[df]["data"]["Voltage"][0] > 0:
                        self.data[df]["data"]["Voltage"] = list(reversed(self.data[df]["data"]["Voltage"])) #if decreasing order, reverse it.
                        self.data[df]["data"]["Capacity"] = list(reversed(self.data[df]["data"]["Capacity"]))
                self.data[df]["data"]["Capacity"] = self.data[df]["data"]["Capacity"] / (float(self.data[df]['header'][0].split(':')[1])*(1e-8)) # Normalize by the Area and convert to cm^2
                CapacityCopy = self.data[df]["data"]["Capacity"].copy()
                capMin= np.max(self.data[df]["data"]["Capacity"][:20]) # Find the Maximum among the first 20 values of the Capacity and set it as minimum Capacity value
                for x in range(len(self.data[df]["data"]["Capacity"])):
                    if CapacityCopy[x] < capMin:
                        CapacityCopy[x] = capMin
                # insert into the data frame
                self.data[df]["data"].insert(3, "CapacityCopy", CapacityCopy)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("CapacityCopy")

                f = interp1d(self.data[df]["data"][self.xaxis], self.data[df]["data"]["CapacityCopy"],kind='cubic')

                xnew = np.arange(self.data[df]['data']['Voltage'][0],list(self.data[df]['data']['Voltage'][-1:])[0],0.001)
                ynew = f(xnew)





                #compute derivatives
                dy1 = np.diff(self.data[df]["data"]["CapacityCopy"])  # compute the difference between each consecutive Capacity value and store it into an array with length i-1
                dx1 = np.diff(self.data[df]["data"][self.xaxis])  # compute the difference between each consecutive voltage value and store it into an array with length i-1
                der1 = dy1 / dx1
                firstdev1 = np.insert(der1, 0, der1[0])  # Add an element to the array to have the same number of rows as in df
                dy2 = np.diff(self.data[df]["data"]["CapacityCopy"],n=2)  # n=2 applies diff() two times to compute the second derivative, dy2 is of lenght i-2
                dy2_2 = np.insert(dy2, 0, dy2[0])  # add one element to dy2 to have the same length of dx1
                der2 = dy2_2 / dx1
                seconddev = np.insert(der2, 0, der2[0])  # Add one element to the array to have the same number of rows as in df


                dy1_interp = np.diff(ynew)
                dx1_interp = np.diff(xnew)
                der1_interp = dy1_interp / dx1_interp
                firstdev1_interp = np.insert(der1_interp, 0, der1_interp[0])
                points = (xnew, firstdev1_interp)
                derivative_interpolation_plot = hv.Curve(points)

                derivative_interpolation_plot = customize_plot(derivative_interpolation_plot, "derivative", self.config["IV_PQC"])

                ele_max = firstdev1_interp.argmax()
                xvals2 = xnew[ele_max]
                maxderiplot = hv.VLine(xvals2).opts(line_width=2.0)
                # TODO: check1
                # insert first derivative into dataframe
                self.data[df]["data"].insert(4, "derivative", firstdev1)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("derivative")


                # insert second derivative into dataframe
                self.data[df]["data"].insert(5, "derivative2", seconddev)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("derivative2")
                # Find the index of the row which contains the maximum value of the second derivative
                indexMax = self.data[df]['data'].index.get_loc(self.data[df]['data']['derivative2'].values.argmax())
                # Find the index of the row which contains the minimum value of the second derivative
                indexMin = self.data[df]['data'].index.get_loc(self.data[df]['data']['derivative2'].values.argmin())
                # Plot all Measurements
                self.donts_mos = ["timestamp", "voltage", "Voltage", "Stepsize", "Wait", "Stepsize", "Frequency", 'x', 'N', 'Current']
                self.basePlots5 = plot_all_measurements(self.data, self.config, self.xaxis, self.name, do_not_plot=self.donts_mos, keys = cv)
                self.PlotDict["BasePlots_MOS"] = self.basePlots5
                # Add flat bandage voltage point to the Capacity curve
                if self.config["IV_PQC"].get("CapacityCopy", {}).get("findFlatBandVoltage", False):
                    try:
                        if self.basePlots5.Overlay.MOS_CV_CURVES.children:
                            clone_plot = self.basePlots5.Overlay.MOS_CV_CURVES.opts(clone=True)
                        else:
                            clone_plot = self.basePlots5.Curve.MOS_CV_CURVES.opts(clone=True)
                        fBestimation = self.find_flatBand_voltage(clone_plot, self.data, self.config, indexMax,indexMin, df, cv,xvals2,
                                                                  PlotLabel="Flat band voltage estimation")
                        fbvoltage.append(fBestimation[1])
                        Accum_capacitance.append(fBestimation[2])
                        Accum_capacitance_normalized.append(fBestimation[3])
                        Tox.append(fBestimation[4])
                        Nox.append(fBestimation[5])
                        self.PlotDict["BasePlots_MOS"] += fBestimation[0] * maxderiplot * derivative_interpolation_plot
                    except Exception as err:
                        self.log.warning("No flat band voltage calculation possible... Error: {}".format(err))
                #Add a Table that shows the differents analysis parameters values
                count += 1
                df2 = pd.DataFrame(
                    {"Name": cv, "Flatband Voltage (V)": fbvoltage, 'Accumulation capacitance (F)': Accum_capacitance,
                     'Accumulation capacitance normalized (F/cm^2)': Accum_capacitance_normalized, 'Tox (nm)': Tox, 'Nox (cm^-2)': Nox})
                table1 = hv.Table((df2), label = 'Mos analysis')
                table1.opts(width=1300, height=800)
                #Do plots
                self.PlotDict["BasePlots_MOS"] += table1
            # Start Diode Analysis
            elif df[0:8] == 'CV_Diode':
                diode.append(df)
                self.data[df]["data"]["Voltage"] = list(map(abs,self.data[df]["data"]["Voltage"])) #take absolute value of Voltage
                self.data[df]["data"].insert(3, "1C2", 1 / self.data[df]["data"]["Capacity"].pow(2))
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("1C2")
                #Compute derivative of 1/C2
                invers_C2_dy = np.diff(self.data[df]["data"]["1C2"])
                invers_C2_dx = np.diff(self.data[df]["data"][self.xaxis])
                der_invers_C2 = invers_C2_dy/invers_C2_dx
                firstdev_invers_C2 = np.insert(der_invers_C2, 0, der_invers_C2[0])  # Add an element to the array to have the same number of rows as in df
                self.data[df]["data"].insert(4, "derivative1C2", firstdev_invers_C2)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("derivative1C2")
                #Calculate deep x
                x = (self.config['IV_PQC_parameter']['epsilonNull']*(1e-6)* float(self.data[df]['header'][0].split(':')[1]) \
                    * self.config['IV_PQC_parameter']['epsilonSiliconOxide']) / self.data[df]["data"]["Capacity"][:42]
                self.data[df]['data'].insert(5, 'x', x)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("x")
                #Calculate doping profile
                N = (2)/(self.config['IV_PQC_parameter']['epsilonNull']*(1e-2) \
                    * self.config['IV_PQC_parameter']['q'] * self.config['IV_PQC_parameter']['epsilonSiliconOxide'] * self.data[df]["data"]["derivative1C2"][:42] \
                              *(float(self.data[df]['header'][0].split(':')[1])*(1e-8))*(float(self.data[df]['header'][0].split(':')[1])*(1e-8)))
                self.data[df]['data'].insert(6, 'N', N)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("N")
                # Plot all Measurements
                self.donts_diode = ["timestamp", "voltage","Voltage","Stepsize","Wait","Stepsize","Frequency",'x','N', 'Capacity','Current'] #do not plot capacity voltage plot
                self.basePlots4 = plot_all_measurements(self.data, self.config, self.xaxis, self.name,
                                                       do_not_plot=self.donts_diode, keys = diode )
                self.PlotDict["BasePlots_diode"] = self.basePlots4
                # Add plot with a different x axis
                self.basePlots_2 = plot_all_measurements(self.data, self.config, 'x', self.name,
                                                         do_not_plot=['Voltage', 'Current', 'Capacity', '1C2',
                                                                      'derivative1C2', 'x'], keys = diode)
                self.PlotDict["BasePlots_diode"] += self.basePlots_2
                # Add full depletion point to 1/c^2 curve
                if self.config["IV_PQC"].get("1C2", {}).get("DoFullDepletionCalculation", False):
                        try:
                            if self.basePlots4.Overlay.A_1C2.children:
                                c2plot = self.basePlots4.Overlay.A_1C2.opts(
                                    clone=True)
                            else:
                                c2plot = self.basePlots4.Curve.A_1C2.opts(clone=True)
                            fdestimation = self.find_full_depletion_c2(c2plot, self.data, self.config, diode,
                                                                       PlotLabel="Full depletion estimation")
                            fdepvoltage.append(fdestimation[1])
                            self.PlotDict["BasePlots_diode"] += fdestimation[0]
                        except Exception as err:
                            self.log.warning("No full depletion calculation possible... Error: {}".format(err))
                # Find resistivity
                C_min = np.mean(self.data[df]['data']['Capacity'][-20:])
                d_active = self.config['IV_PQC_parameter']['epsilonNull'] * self.config['IV_PQC_parameter']['epsilonSiliconOxide'] * (float(self.data[df]['header'][0].split(':')[1]) * (1e-8)) * (1e-2)/ C_min # in cm
                T_n= 295/300
                u_holes_mobility = 54.3*pow(T_n,-0.57) +1.36*(1e+8)* pow(295,-2.23)/(1+((5e+12)/(2.35*(1e+17)*pow(T_n,2.4)))*0.88*pow(T_n,-0.146)) # in cm^2/(V*s)
                rho = d_active * d_active / (
                            2 * self.config['IV_PQC_parameter']['epsilonNull']*(1e-2) * self.config['IV_PQC_parameter'][
                        'epsilonSiliconOxide'] * fdestimation[1] * u_holes_mobility) # in Ohm * cm
                rho_table = '{:.2e}'.format(rho)
                resistivity = []
                resistivity.append(rho_table)
                #Add a table that show the results of the analysis
                count2 += 1
                df3 = pd.DataFrame({"Name": diode, "full depletion voltage (V)": fdepvoltage, " Bulk resistivity (Ohm * cm)": resistivity})
                table2=hv.Table((df3), label = 'Diode analysis')
                table2.opts(width=1300, height=800)
                self.PlotDict["BasePlots_diode"] += table2




            # Start Gate analysis
            else:
                gate.append(df)
                dy1 = np.diff(self.data[df]["data"][
                                  "Current"])  # compute the difference between each consecutive Capacity value and store it into an array with length i-1
                dx1 = np.diff(self.data[df]["data"]["Voltage"])  # compute the difference between each consecutive voltage value and store it into an array with length i-1
                der1 = dy1 / dx1
                firstdev3 = np.insert(der1, 0, der1[0])  # Add an element to the array to have the same number of rows as in df
                # insert first derivative into dataframe
                self.data[df]["data"].insert(3, "firstderivative_gate", firstdev3)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("firstderivative_gate")

                # Find the index of the row which contains the maximum value of the second derivative
                indexMax7 = self.data[df]['data'].index.get_loc(self.data[df]['data']['firstderivative_gate'][10:].values.argmax())
                # Find the index of the row which contains the minimum value of the second derivative
                indexMin7 = self.data[df]['data'].index.get_loc(self.data[df]['data']['firstderivative_gate'][10:].values.argmin())
                #mean indexes
                indexstart = indexMax7+10+10 #first +10 to account for the 10: in index max, second to be sure to be in the plateau region
                indexend = indexMin7-10+10
                I_surf_maxima_average = np.mean(self.data[df]['data']['Current'][indexstart:indexend])




                mxx = max(self.data[df]['data']['Current']) # find maximum of value of the current-voltage curve
                minx = np.mean(self.data[df]['data']['Current'][-20:]) # find the minimum of the current-voltage curve by averaging 20 points values in the curve tail
                I_surf_average = I_surf_maxima_average - minx
                I_surf_average_table = '{:.2e}'.format(I_surf_average)
                Surface_current_average.append(I_surf_average_table)

                Isurf_max = mxx - minx # compute the surface current
                Isurf_table = '{:.2e}'.format(Isurf_max)
                Surface_current.append(Isurf_table)
                S_null_max = Isurf_max/(self.config['IV_PQC_parameter']['q'] * self.config['IV_PQC_parameter']['n_i_intrinsic_carrier_concentration'] * (float(self.data[df]['header'][0].split(':')[1]) *(1e-8)))
                Surface_recombination_velocity.append(S_null_max)
                S_null_average = I_surf_average/(self.config['IV_PQC_parameter']['q'] * self.config['IV_PQC_parameter']['n_i_intrinsic_carrier_concentration'] * (float(self.data[df]['header'][0].split(':')[1])  *(1e-8)))
                Surface_recombination_velocity_average.append(S_null_average)

                # Add text to the plot
                text = hv.Text(3, 9 * (1e-11), 'Isurf_max: {} A\n'
                               'Isurf_average: {} A\n'
                               'Surface recombination velocity_max: {} cm/s\n'
                               'Surface recombination velocity_average: {} cm/s'.format(
                    np.round(Isurf_max, 15), np.round(I_surf_average, 15) , np.round(S_null_max,4), np.round(S_null_average,4))
                               ).opts(style=dict(text_font_size='20pt'))


                # Plot all Measurements
                self.basePlots3 = plot_all_measurements(self.data, self.config, self.xaxis, self.name,
                                                       do_not_plot=self.donts, keys = gate)

                #do this if the analysis is of just one file
                if len(gate) == 1:
                    firstDerivative_gatePlot = self.basePlots3.Curve.firstderivative_gate
                    #self.basePlots3.Current.opts(Plotlabel='test')
                    Path_min = hv.Path([(-2, minx), (6, minx)]).opts(line_width=2.0)
                    Path_mxx = hv.Path([(-2, mxx), (6, mxx)]).opts(line_width=2.0)
                    Path_average =  hv.Path([(-2, I_surf_maxima_average), (6, I_surf_maxima_average)]).opts(line_width=2.0)
                   # Path_Isurf = hv.Path([(0, mxx), (0, min)]).opts(line_width=3.0)
                    self.PlotDict["BasePlots_gate"] = self.basePlots3.Curve.Current_Gate *text * Path_min * Path_mxx * Path_average # * Path_Isurf
                    self.PlotDict["BasePlots_gate"] += firstDerivative_gatePlot

                    #add table that shows resulting parameters of the analysis
                    count3 += 1
                    df4 = pd.DataFrame({"Name": gate, "Surface current_max (A)": Surface_current, "Surface current_average (A)": Surface_current_average,
                                        'Surface recombination velocity_max (cm/s)': Surface_recombination_velocity, 'Surface recombination velocity_average (cm/s)': Surface_recombination_velocity_average })
                    table3 = hv.Table((df4), label = 'Gate analysis')
                    table3.opts(width=1300, height=800)
                    self.PlotDict["BasePlots_gate"] += table3

                # do this if the analysis is of more than one file
                elif len(gate) > 1:
                    #self.basePlots3.Overlay.Current.opts(Plotlabel = 'test')
                    self.PlotDict["BasePlots_gate"] = self.basePlots3
                    # add table that shows resulting parameters of the analysis
                    count3 += 1
                    df4 = pd.DataFrame({"Name": gate, "Surface current_max (A)": Surface_current, "Surface current_average (A)": Surface_current_average,
                                        'Surface recombination velocity_max (cm/s)': Surface_recombination_velocity, 'Surface recombination velocity_average (cm/s)': Surface_recombination_velocity_average })
                    table3 = hv.Table((df4), label = 'Gate analysis')
                    table3.opts(width=1300, height=800)
                    self.PlotDict["BasePlots_gate"] += table3

        if count != 0 and count2 !=0 and count3 != 0:
            self.PlotDict['All'] =  self.PlotDict["BasePlots_gate"] + self.PlotDict["BasePlots_diode"] + self.PlotDict["BasePlots_MOS"]
        elif count != 0 and count2 !=0 and count3 == 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_diode"] + self.PlotDict["BasePlots_MOS"]

        elif count == 0 and count2 !=0 and count3 == 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_diode"]
        elif count != 0 and count2 ==0 and count3 == 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_MOS"]

        elif count == 0 and count2 ==0 and count3 != 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_gate"]
        elif count != 0 and count2 ==0 and count3 != 0:
            self.PlotDict['All'] =  self.PlotDict["BasePlots_gate"] + self.PlotDict["BasePlots_MOS"]
        else:
            self.PlotDict['All'] = self.PlotDict["BasePlots_diode"] + self.PlotDict["BasePlots_gate"]

        self.PlotDict["All"] = applyPlotOptions(self.PlotDict["All"],
                                                {'Curve': {'color': "hv.Palette('Category20')"}}) # To change colors

        return self.PlotDict

    def find_flatBand_voltage(self, plot, data, configs, indexMax, indexMin, df,cv, xvals2, **addConfigs,):
        """
        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the
        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.
        :param plot: The plot object
        :param data: The data files
        :param configs: the configs
        :param **addConfigs: the configs special for the 1/C2 plot, it is recommended to pass the same options here again, like in the original plot!
        :return: The updated plot
        """

        self.log.info("Searching for flat band voltage voltage in all files...")

        sample = deepcopy(data[df])
        #Create a new data frame with just two columns
        try:
            df1 = pd.DataFrame({"xaxis": sample["data"]["voltage"], "yaxis": sample["data"]["CapacityCopy"]})
        except:
            df1 = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["CapacityCopy"]})
        df1 = df1.dropna()

        # Loop one time from the right side, to get the slope of the accumulation region, and then loop on the fit region to get the fit slope
        RR2 = 0
        fitR2 = 0
        for idx in range(5, len(df1)-5):
            # Right
            slope_right, intercept_right, r_right, p_value, std_err_right = linregress(df1["xaxis"][idx:],df1["yaxis"][idx:])
            r2_right = r_right * r_right
            self.log.debug("Right side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                slope_right, intercept_right, r2_right, std_err_right)
            )
            # See if the r2 value has increased and store it
            if r2_right >= RR2:
                RR2 = r2_right
                RightEndPoints = (
                    (df1["xaxis"][idx], slope_right * df1["xaxis"][idx] + intercept_right),
                    (df1["xaxis"][len(df1["xaxis"]) - 1], slope_right * df1["xaxis"][len(df1["xaxis"]) - 1] + intercept_right),
                )
                Right_stats = [RightEndPoints, slope_right, intercept_right, r_right, p_value, std_err_right]


        # Fit central region
        for idx in range(indexMax, indexMin-2):
            #Central fit
            slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit = linregress(df1["xaxis"][idx:indexMin-2],
                                                                                  df1["yaxis"][idx:indexMin-2])
            r2_fit = r_fit * r_fit
            self.log.debug("central fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                slope_fit, intercept_fit, r2_fit, std_err_fit)
            )
            # See if the r2 value has increased and store it
            if r2_fit >= fitR2:
                fitR2 = r2_fit
                fitEndPoints = (
                    (df1["xaxis"][indexMax], slope_fit * df1["xaxis"][indexMax] + intercept_fit),
                    (df1["xaxis"][idx+1], slope_fit * df1["xaxis"][idx+1] + intercept_fit) # use idx +1 to avoid having the same end points
                )
                fit_stats = [fitEndPoints, slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit]


        # Add central slope
        xmax = df1["xaxis"][indexMin]

        fit_line = np.array([[df1["xaxis"][indexMax-3], fit_stats[1] * df1["xaxis"][indexMax-3]  + fit_stats[2]],
                               [xmax+0.2, fit_stats[1] * (xmax+0.2) + fit_stats[2]]])

        # Add right slope
        xmax = df1["xaxis"][len(df1["yaxis"]) - 1]
        right_line = np.array([[df1["xaxis"][indexMax-3], Right_stats[1] *df1["xaxis"][indexMax-3] + Right_stats[2]],
                               [xmax, Right_stats[1] * xmax + Right_stats[2]]])



        # Compute the flatband voltage
        flatband_voltage = line_intersection(fit_stats[0], Right_stats[0])
        self.log.info("Flatband voltage to data file {} is {}".format(df,
                                                                                                     flatband_voltage[
                                                                                                          0]))



        # Find oxide thickness Tox in nm
        Accum_capacitance = np.max(df1["yaxis"]) * (float(self.data[df]['header'][0].split(':')[1]) * (
            1e-8))  # float(..) is the area.
        Accum_capacitance_table = '{:.2e}'.format(Accum_capacitance)
        Accum_capacitance_normalized = np.max(df1["yaxis"])  # F/cm^2
        Accum_capacitance_normalized_table = '{:.2e}'.format(Accum_capacitance_normalized)
        Tox = self.config['IV_PQC_parameter']['epsilonNull'] * self.config['IV_PQC_parameter'][
            'epsilonSiliconOxide'] * 1e+5 / Accum_capacitance_normalized
        Tox_table = '{:.2e}'.format(Tox)
        # Find Fixed oxide charge Nox in cm^-2
        phi_s = self.config['IV_PQC_parameter']['electronAffinity'] + self.config['IV_PQC_parameter'][
            'bandGapEnergy'] / 2 \
                + (self.config['IV_PQC_parameter']['boltzmannConstant'] * self.config['IV_PQC_parameter']['Temperature']
                   * np.log(self.config['IV_PQC_parameter']['SiliconDoping'] / self.config['IV_PQC_parameter'][
                    'intrinsicDopingConcentration'])) / self.config['IV_PQC_parameter']['q']
        phi_ms = self.config['IV_PQC_parameter']['phi_m'] - phi_s
        self.log.info("Test4 for flat band voltage voltage in all files...")
        Nox = (Accum_capacitance_normalized * (phi_ms + flatband_voltage[0])) / (self.config['IV_PQC_parameter']['q'])
        self.log.info("Test41 for flat band voltage voltage in all files...")
        Nox_table = '{:.2e}'.format(Nox)
        # Add text
        text = hv.Text(10, 0.00000000065, 'Flat band voltage: {} V \n'
                                            'Flat band voltage first derivative: {} V \n'

                                            'C accumulation: {} F \n'

                                            'C accumulation/A: {} F/cm\N{SUPERSCRIPT TWO} \n'

                                            'Tox: {} nm \n'
                                            'Nox: {} cm\N{SUPERSCRIPT MINUS}\N{SUPERSCRIPT TWO}'.format(
            np.round(np.median(flatband_voltage[0]), 2),
            np.round(xvals2, 2),
            np.round(Accum_capacitance, 10),
            np.round(Accum_capacitance_normalized, 10),
            np.round(Tox, 2),
            np.format_float_scientific(Nox, 2))

                       ).opts(style=dict(text_font_size='25pt'))


        #if more than one file do not do the derivates plot
        if not len(cv) == 1:
            # Update the plot specific options if need be
            returnPlot = plot
            # returnPlot = relabelPlot(returnPlot, "MOS_CV CURVES - Full depletion calculation")
            returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)

            return returnPlot, flatband_voltage[0], Accum_capacitance_table, Accum_capacitance_normalized_table, Tox_table, Nox_table



        elif len(cv) == 1:
            #plot a vertical line where the fb voltage is
            vline = hv.VLine(flatband_voltage[0]).opts(color='black', line_width=2.0)


            # Plots of the derivatives
            firstDerivativePlot= self.basePlots5.Curve.firstderivative
            secondDerivativePlot = self.basePlots5.Curve.secondderivative
            # Plots of the fits
            right_line = hv.Curve(right_line).opts(color='blue')
            fit_line = hv.Curve(fit_line).opts(color='red', line_width=3.0)

            # Update the plot specific options if need be
            returnPlot = plot * right_line * fit_line * text * secondDerivativePlot * firstDerivativePlot * vline
            # returnPlot = relabelPlot(returnPlot, "MOS_CV CURVES - Full depletion calculation")
            returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)

            return returnPlot, flatband_voltage[0], Accum_capacitance_table, Accum_capacitance_normalized_table, Tox_table, Nox_table



    def find_full_depletion_c2(self, plot, data, configs,diode, **addConfigs):

        """

        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the

        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.

        :param plot: The plot object

        :param data: The data files

        :param configs: the configs

        :param **addConfigs: the configs special for the 1/C2 plot, it is recomended to pass the same options here again, like in the original plot!

        :return: The updated plot

        """



        full_depletion_voltages = np.zeros((len(diode), 2))

        Left_stats = np.zeros((len(diode), 6), dtype=np.object)

        Right_stats = np.zeros((len(diode), 6), dtype=np.object)

        self.log.info("Searching for full depletion voltage in all files...")



        for i, samplekey in enumerate(diode):

            if "1C2" not in data[samplekey]["data"]:

                self.log.warning("Full depletion calculation could not be done for data set: {}".format(samplekey))



            else:

                self.log.debug("Data: {}".format(samplekey))

                sample = deepcopy(data[samplekey])

                df = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["1C2"]})

                df = df.dropna()





                # Loop one time from the right side and from the left, to get both slopes

                LR2 = 0 # r^2 values for both sides

                RR2 = 0





                for idx in range(5, len(df)-5):

                    # Left

                    slope_left, intercept_left, r_left, p_value, std_err_left = linregress(df["xaxis"][:-idx],df["yaxis"][:-idx])

                    r2_left = r_left * r_left

                    self.log.debug("Left side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(

                        slope_left, intercept_left, r2_left, std_err_left)

                    )



                    # Right

                    slope_right, intercept_right, r_right, p_value, std_err_right = linregress(df["xaxis"][idx:],df["yaxis"][idx:])

                    r2_right = r_right * r_right

                    self.log.debug("Right side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(

                        slope_right, intercept_right, r2_right, std_err_right)

                    )



                    # See if the r2 value has increased and store end points

                    if r2_left >= LR2:

                        LR2 = r2_left

                        LeftEndPoints = (

                            (df["xaxis"][0], intercept_left),

                            (df["xaxis"][idx], slope_left * df["xaxis"][idx] + intercept_left)

                        )

                        Left_stats[i] = (LeftEndPoints, slope_left, intercept_left, r_left, p_value, std_err_left)



                    # See if the r2 value has increased and store it

                    if r2_right >= RR2:

                        RR2 = r2_right

                        RightEndPoints = (

                            (df["xaxis"][idx], slope_right * df["xaxis"][idx] + intercept_right),

                            (df["xaxis"][len(df["xaxis"]) - 1], slope_right * df["xaxis"][len(df["xaxis"]) - 1] + intercept_right),

                        )

                        Right_stats[i] = (RightEndPoints, slope_right, intercept_right, r_right, p_value, std_err_right)



                # Make the line intersection

                full_depletion_voltages[i] = line_intersection(LeftEndPoints, RightEndPoints)



        # Add vertical line for full depletion

        # Find nonzero indizes

        valid_indz = np.nonzero(full_depletion_voltages[:, 0])

        vline = hv.VLine(np.median(full_depletion_voltages[valid_indz], axis=0)[0]).opts(color='black', line_width=5.0)



        # Add slopes

        xmax = df["xaxis"][len(df["yaxis"])-1]

        left_line = np.array([[0, np.median(Left_stats[:,2])],[xmax, np.median(Left_stats[:,1])*xmax + np.median(Left_stats[:,2])]])

        left_line = hv.Curve(left_line).opts(color='grey')



        right_line = np.array([[0, np.median(Right_stats[:,2])],[xmax, np.median(Right_stats[:,1])*xmax + np.median(Right_stats[:,2])]])

        right_line = hv.Curve(right_line).opts(color='grey')



        # Add text

        self.log.info('Full depletion voltage: {} V'

                        .format(np.round(np.median(full_depletion_voltages[valid_indz, 0]), 2)))



        text = hv.Text(230, (5e+21), 'Depletion voltage: {} V'.format(np.round(np.median(full_depletion_voltages[:, 0]), 2))).opts(style=dict(text_font_size='20pt'))





        # Update the plot specific options if need be

        returnPlot = plot * vline * right_line * left_line * text

        returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)


        return returnPlot, full_depletion_voltages[0][0]
