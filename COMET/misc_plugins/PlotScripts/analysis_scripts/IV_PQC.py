"""This script plots IVCV files together for files generated by QTC
Data must be """

import logging
import holoviews as hv
from scipy.stats import linregress
import scipy.signal
from copy import deepcopy
from scipy.interpolate import interp1d
import pandas as pd
import numpy as np
from forge.tools import customize_plot, holoplot, convert_to_df, config_layout, applyPlotOptions
from forge.tools import plot_all_measurements, convert_to_EngUnits
from forge.utilities import line_intersection



class IV_PQC:

    def __init__(self, data, configs):
        if not all(i[0:6] == 'IV_GCD' for i in list(data.keys())):
            i = 0
            while list(data.keys())[0][0:6] == 'IV_GCD':
                data[list(data.keys())[0] + str(i)] = data[list(data.keys())[0]]
                del data[list(data.keys())[0]]
                i += 1
        self.log = logging.getLogger(__name__)
        self.data = convert_to_df(data, abs=False, keys= 'all')
        self.config = configs
        self.df = []
        self.basePlots = None
        self.basePlots_2 = None
        self.name = "IV_PQC"
        self.PlotDict = {"Name": "IV"}
        self.capincluded = False

        # add a copyCapacity, first and second derivatives for the cv_mos analysis to the data frame;
        # add a 1/C2, the derivative of 1/C2, add the deep x and the surface doping profile N to the data frame;


        self.data["columns"].insert(3, "CapacityCopy")
        self.data["columns"].insert(4, "derivative")
        self.data["columns"].insert(5, "derivative2")
        self.data["columns"].insert(6, "1C2")
        self.data["columns"].insert(7,"derivative1C2")
        self.data["columns"].insert(8, "x")
        self.data["columns"].insert(9, "N")
        self.data["columns"].insert(10, "firstderivative_gate")
        self.capincluded = True


        self.measurements = self.data["columns"]
        self.xaxis = self.measurements[0]
        self.donts = ["timestamp", "voltage","Voltage","Stepsize","Wait","Stepsize","Frequency",'x','N'] #do not plot this data
        hv.renderer('bokeh')

        # Convert the units to the desired ones
        for meas in self.measurements:
            unit = self.config[self.name].get(meas, {}).get("UnitConversion", None)
            if unit:
                self.data = convert_to_EngUnits(self.data, meas, unit)



    def run(self):
        """Runs the script"""
        fbvoltage = [] #list that is used later on to store the flat band voltage values for all the different files used in the analysis
        fbvoltage_firstderivative = [] #list that is used later on to store the flat band voltage values computed with the first derivative for all the different files used in the analysis
        Accum_capacitance = [] #list that is used later on to store the accumulation capacitance values for all the different files used in the analysis
        Accum_capacitance_normalized = [] #list that is used later on to store the area-normalized accumulation capacitance values for all the different files used in the analysis
        Tox = [] #list that is used later on to store the oxide thickness values for all the different files used in the analysis
        Nox = [] #list that is used later on to store the oxide charge values for all the different files used in the analysis
        fdepvoltage = [] #list that is used later on to store the full depletion  voltage values for all the different files used in the analysis
        count = 0
        count2 = 0
        count3 = 0
        diode = [] #list that is used later on to store all the files used in the diode analysis
        cv = [] #list that is used later on to store all the files used in the mos analysis
        gate = [] #list that is used later on to store all the files used in the gate analysis
        Surface_current = [] #list that is used later on to store the surface current values for all the different gate files used in the analysis
        Surface_recombination_velocity = [] #list that is used later on to store the surface recombination velocity values for all the different gate files used in the analysis
        Surface_current_average = [] #list that is used later on to store the surface current values for all the different gate files used in the analysis
        Surface_recombination_velocity_average = [] #list that is used later on to store the surface recombination velocity values for all the different gate files used in the analysis
        resistivity = []


        # Add the 1/c^2 data to the dataframes
        # Add a copy of the Capacity values to the data frame, where the small kink in the plot is deleted
        for df in self.data["keys"]:

            # Start the cv_mos analysis
            if self.data[df]['header'][1][0:8] != 'CV_Diode' and self.data[df]['header'][1][0:6] != 'IV_GCD': #If not Diode or Gate analysis do the cv mos analysis
                cv.append(df)
                if 'Voltage' in self.data[df]['data']: # Check that the voltage values have increasing order
                    if self.data[df]["data"]["Voltage"][0] > 0:
                        self.data[df]["data"]["Voltage"] = list(reversed(self.data[df]["data"]["Voltage"])) #if decreasing order, reverse it.
                        self.data[df]["data"]["Capacity"] = list(reversed(self.data[df]["data"]["Capacity"]))
                self.data[df]["data"]["Capacity"] = self.data[df]["data"]["Capacity"] / (float(self.data[df]['header'][0].split(':')[1])*(1e-8)) # Normalize by the Area and convert to cm^2
                CapacityCopy = self.data[df]["data"]["Capacity"].copy()
                capMin= np.max(self.data[df]["data"]["Capacity"][:20]) # Find the Maximum among the first 20 values of the Capacity and set it as minimum Capacity value
                for x in range(len(self.data[df]["data"]["Capacity"])):
                    if CapacityCopy[x] < capMin:
                        CapacityCopy[x] = capMin
                # insert into the data frame
                self.data[df]["data"].insert(3, "CapacityCopy", CapacityCopy)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("CapacityCopy")

                f = interp1d(self.data[df]["data"][self.xaxis], self.data[df]["data"]["CapacityCopy"],kind='cubic')

                xnew = np.arange(self.data[df]['data']['Voltage'][0],list(self.data[df]['data']['Voltage'][-1:])[0],0.001)
                ynew = f(xnew)
                points3 = (xnew,ynew)
                capa_interp_plot = hv.Curve(points3)
                capa_interp_plot = customize_plot(capa_interp_plot, "Capacity", self.config["IV_PQC"])

                dx1 = np.diff(self.data[df]["data"][self.xaxis])
                dy2 = np.diff(self.data[df]["data"]["CapacityCopy"],
                              n=2)  # n=2 applies diff() two times to compute the second derivative, dy2 is of lenght i-2
                dy2_2 = np.insert(dy2, 0, dy2[0])  # add one element to dy2 to have the same length of dx1
                der2 = dy2_2 / dx1
                seconddev = np.insert(der2, 0,
                                      der2[0])  # Add one element to the array to have the same number of rows as in df



                #compute derivatives
                dx1_interp = np.diff(xnew)
                dy1_interp = np.diff(ynew)
                dy2_interp = np.diff(ynew,n=2)
                dy2_2_interp = np.insert(dy2_interp, 0, dy2_interp[0]) #add a point to the array
                der2_interp = dy2_2_interp / dx1_interp
                der1_interp = dy1_interp / dx1_interp
                firstdev1_interp = np.insert(der1_interp, 0, der1_interp[0])
                seconddev_interp = np.insert(der2_interp, 0, der2_interp[0])
                points = (xnew, firstdev1_interp)
                derivative_interpolation_plot = hv.Curve(points)
                derivative_interpolation_plot = customize_plot(derivative_interpolation_plot, "derivative", self.config["IV_PQC"])
                points2 = (xnew,seconddev_interp)
                secondderivative_interp_plot = hv.Curve(points2)
                secondderivative_interp_plot = customize_plot(secondderivative_interp_plot, "derivative2", self.config["IV_PQC"])

                ele_max = firstdev1_interp.argmax()
                xvals2 = xnew[ele_max]
                maxderiplot = hv.VLine(xvals2).opts(line_width=1.0)
                fbvoltage_firstderivative.append(xvals2)
                # TODO: check1
                # insert first derivative into dataframe
                #self.data[df]["data"].insert(4, "derivative", firstdev1)
                #self.data[df]["units"].append("arb. units")
                #self.data[df]["measurements"].append("derivative")


                # insert second derivative into dataframe
                self.data[df]["data"].insert(5, "derivative2", seconddev)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("derivative2")
                # Find the index of the row which contains the maximum value of the second derivative
                indexMax = self.data[df]['data'].index.get_loc(self.data[df]['data']['derivative2'].values.argmax())

                # Find the index of the row which contains the minimum value of the second derivative
                indexMin = self.data[df]['data'].index.get_loc(self.data[df]['data']['derivative2'].values.argmin())

                # Plot all Measurements
                self.donts_mos = ["timestamp", "voltage", "Voltage", "Stepsize", "Wait", "Stepsize", "Frequency", 'x', 'N', 'Current']
                self.basePlots5 = plot_all_measurements(self.data, self.config, self.xaxis, self.name, do_not_plot = self.donts_mos, keys = cv)
                self.PlotDict["BasePlots_MOS"] = self.basePlots5
                # Add flat bandage voltage point to the Capacity curve
                if self.config["IV_PQC"].get("CapacityCopy", {}).get("findFlatBandVoltage", False):
                    try:
                        if self.basePlots5.Overlay.MOS_CV_CURVES.children:
                            clone_plot = self.basePlots5.Overlay.MOS_CV_CURVES.opts(clone=True)
                        else:
                            clone_plot = self.basePlots5.Curve.MOS_CV_CURVES.opts(clone=True)
                        fBestimation = self.find_flatBand_voltage(clone_plot, self.data, self.config, indexMax, indexMin, df, cv, xvals2,
                                                                  PlotLabel="Flat band voltage estimation")
                        fbvoltage.append(fBestimation[1])
                        Accum_capacitance.append(fBestimation[2])
                        Accum_capacitance_normalized.append(fBestimation[3])
                        Tox.append(fBestimation[4])
                        Nox.append(fBestimation[5])

                    except Exception as err:
                        self.log.warning("No flat band voltage calculation possible... Error: {}".format(err))

                count += 1
                if count == 1:
                    self.PlotDict["BasePlots_MOS"] += fBestimation[0]
                    self.PlotDict["BasePlots_MOS"] += derivative_interpolation_plot
                    self.PlotDict["BasePlots_MOS"] += secondderivative_interp_plot
                    self.PlotDict["BasePlots_MOS"] += capa_interp_plot
                    self.PlotDict["BasePlots_MOS"] += capa_interp_plot * maxderiplot * derivative_interpolation_plot * secondderivative_interp_plot
                    self.PlotDict["BasePlots_MOS"] += fBestimation[6] * maxderiplot * derivative_interpolation_plot
                #Add a Table that shows the differents analysis parameters values
                df2 = pd.DataFrame(
                    {"Name": cv, "Flatband Voltage second_derivative (V)": fbvoltage, 'Flatband Voltage first_derivative (V)': fbvoltage_firstderivative,  'Accumulation capacitance (F)': Accum_capacitance,
                     'Accumulation capacitance normalized (F/cm^2)': Accum_capacitance_normalized, 'Tox (nm)': Tox, 'Nox (cm^-2)': Nox})
                table1 = hv.Table((df2), label = 'Mos analysis')
                table1.opts(width=1300, height=800)
                #Do plots
                self.PlotDict["BasePlots_MOS"] += table1

            # Start Diode Analysis
            elif self.data[df]['header'][1][0:8] == 'CV_Diode':
                diode.append(df)
                self.data[df]["data"]["Voltage"] = list(map(abs,self.data[df]["data"]["Voltage"])) #take absolute value of Voltage


                #######trial
                #interpolate the capacity
                f = interp1d(self.data[df]["data"][self.xaxis], self.data[df]["data"]["Capacity"],kind='cubic')
                xnew = np.arange(self.data[df]['data']['Voltage'][0],list(self.data[df]['data']['Voltage'][-1:])[0],0.001)
                ynew = f(xnew)
                Onec2 = 1/(ynew * ynew)  #1C2 array
                #derivative
                dx = np.diff(xnew)
                dy = np.diff(Onec2)
                derivative = dy/dx
                add_element_derivative = np.insert(derivative, 0, derivative[0])
                points_capacity = (xnew,Onec2)
                capacity_curve = hv.Curve(points_capacity)
                capacity_curve = customize_plot(capacity_curve, "1C2", self.config["IV_PQC"]) ##curve 1c2
                points_derivative_onec2 = (xnew, add_element_derivative)
                derivative_onec2_curve = hv.Curve(points_derivative_onec2)
                derivative_onec2_curve = customize_plot(derivative_onec2_curve, "1C2", self.config["IV_PQC"])

                #savgolay plot
                yhat = scipy.signal.savgol_filter(add_element_derivative, 5, 2)  # window size 51, polynomial order 3
                points15 = (xnew, yhat)
                deronec2_savgol_plot = hv.Curve(points15)
                deronec2_savgol_plot = customize_plot(deronec2_savgol_plot, "1C2", self.config["IV_PQC"])
                #####finsih trial

                #continue normal analysis

                self.data[df]["data"].insert(3, "1C2", 1 / self.data[df]["data"]["Capacity"].pow(2))
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("1C2")
                #Compute derivative of 1/C2
                invers_C2_dy = np.diff(self.data[df]["data"]["1C2"])
                invers_C2_dx = np.diff(self.data[df]["data"][self.xaxis])
                der_invers_C2 = invers_C2_dy/invers_C2_dx
                firstdev_invers_C2 = np.insert(der_invers_C2, 0, der_invers_C2[0])  # Add an element to the array to have the same number of rows as in df
                self.data[df]["data"].insert(4, "derivative1C2", firstdev_invers_C2)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("derivative1C2")
                #Calculate deep x
                x = (self.config['IV_PQC_parameter']['epsilonNull']*(1e-6)* float(self.data[df]['header'][0].split(':')[1]) \
                    * self.config['IV_PQC_parameter']['epsilonSiliconOxide']) / self.data[df]["data"]["Capacity"][:42]
                self.data[df]['data'].insert(5, 'x', x)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("x")
                #Calculate doping profile
                N = (2)/(self.config['IV_PQC_parameter']['epsilonNull']*(1e-2) \
                    * self.config['IV_PQC_parameter']['q'] * self.config['IV_PQC_parameter']['epsilonSiliconOxide'] * self.data[df]["data"]["derivative1C2"][:42] \
                              *(float(self.data[df]['header'][0].split(':')[1])*(1e-8))*(float(self.data[df]['header'][0].split(':')[1])*(1e-8)))
                self.data[df]['data'].insert(6, 'N', N)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("N")
                # Plot all Measurements
                self.donts_diode = ["timestamp", "voltage","Voltage","Stepsize","Wait","Stepsize","Frequency",'x','N', 'Capacity','Current'] #do not plot capacity voltage plot
                self.basePlots4 = plot_all_measurements(self.data, self.config, self.xaxis, self.name,
                                                       do_not_plot=self.donts_diode, keys = diode )
                self.PlotDict["BasePlots_diode"] = self.basePlots4
                # Add plot with a different x axis
                self.basePlots_2 = plot_all_measurements(self.data, self.config, 'x', self.name,
                                                         do_not_plot=['Voltage', 'Current', 'Capacity', '1C2',
                                                                      'derivative1C2', 'x'], keys = diode)
                self.PlotDict["BasePlots_diode"] += self.basePlots_2

                #add trial plots

                self.PlotDict["BasePlots_diode"] += capacity_curve
                self.PlotDict["BasePlots_diode"] += derivative_onec2_curve * deronec2_savgol_plot
                self.PlotDict["BasePlots_diode"] += deronec2_savgol_plot


                # Add full depletion point to 1/c^2 curve
                if self.config["IV_PQC"].get("1C2", {}).get("DoFullDepletionCalculation", False):
                        try:
                            if self.basePlots4.Overlay.A_1C2.children:
                                c2plot = self.basePlots4.Overlay.A_1C2.opts(
                                    clone=True)
                            else:
                                c2plot = self.basePlots4.Curve.A_1C2.opts(clone=True)
                            fdestimation = self.find_full_depletion_c2(c2plot, self.data, self.config, diode,
                                                                       PlotLabel="Full depletion estimation")
                            fdepvoltage.append(fdestimation[1])
                            #self.PlotDict["BasePlots_diode"] += fdestimation[0]
                        except Exception as err:
                            self.log.warning("No full depletion calculation possible... Error: {}".format(err))
                # Find resistivity
                C_min = np.mean(self.data[df]['data']['Capacity'][-20:])
                d_active = self.config['IV_PQC_parameter']['epsilonNull'] * self.config['IV_PQC_parameter']['epsilonSiliconOxide'] * (float(self.data[df]['header'][0].split(':')[1]) * (1e-8)) * (1e-2)/ C_min # in cm
                T_n= 295/300
                u_holes_mobility = 54.3*pow(T_n,-0.57) +1.36*(1e+8)* pow(295,-2.23)/(1+((5e+12)/(2.35*(1e+17)*pow(T_n,2.4)))*0.88*pow(T_n,-0.146)) # in cm^2/(V*s)
                rho = d_active * d_active / (
                            2 * self.config['IV_PQC_parameter']['epsilonNull']*(1e-2) * self.config['IV_PQC_parameter'][
                        'epsilonSiliconOxide'] * fdestimation[1] * u_holes_mobility) # in Ohm * cm
                rho_table = '{:.2e}'.format(rho)
                resistivity.append(rho_table)
                #Add a table that show the results of the analysis
                count2 += 1

                if count2 ==1:
                    self.PlotDict["BasePlots_diode"] += fdestimation[0]
                    df3 = pd.DataFrame({"Name": diode, "full depletion voltage (V)": fdepvoltage,
                                        " Bulk resistivity (Ohm * cm)": resistivity})
                    table2 = hv.Table((df3), label='Diode analysis')
                    table2.opts(width=1300, height=800)
                    self.PlotDict["BasePlots_diode"] += table2
                else:
                    df3 = pd.DataFrame({"Name": diode, "full depletion voltage (V)": fdepvoltage,
                                        " Bulk resistivity (Ohm * cm)": resistivity})
                    table2 = hv.Table((df3), label='Diode analysis')
                    table2.opts(width=1300, height=800)
                    self.PlotDict["BasePlots_diode"] += table2

            # Start Gate analysis
            else:
                gate.append(df)

                start_value = np.mean(self.data[df]['data']['Current'][10:20])


                CurrentCopy = self.data[df]["data"]["Current"].copy()
                for x in range(int(len(self.data[df]["data"]["Current"])/2)):
                    if CurrentCopy[x] < start_value:
                        CurrentCopy[x] = start_value

                points12 = (self.data[df]["data"][self.xaxis],CurrentCopy)
                plot_not_kink = hv.Curve(points12,label='Capacitance')
                plot_not_kink = customize_plot(plot_not_kink, "Current", self.config["IV_PQC"])

                try:
                    y = self.data[df]['data']['Current']

                    i=0
                    while i<2:
                        y = scipy.signal.savgol_filter(y, 31, 3)  # window size 51, polynomial order 3
                        i += 1

                    maxsavgol = max(y)
                    points13 = (self.data[df]['data']['Voltage'], y)
                    curr_savgol_plot = hv.Curve(points13)
                    curr_savgol_plot = customize_plot(curr_savgol_plot, "SavgolCurrent", self.config["IV_PQC"])
                except:
                    print('Exception for the savgol plot')

                f = interp1d(self.data[df]["data"][self.xaxis], CurrentCopy, kind='cubic')
                xnew = np.arange(self.data[df]['data']['Voltage'][0], list(self.data[df]['data']['Voltage'][-1:])[0],
                                     0.001)


                try:
                    ynew = f(xnew)
                except:
                    ynew = np.arange(len(list(xnew)))
                points4 = (xnew, ynew)
                curr_interp_plot = hv.Curve(points4).opts(title="Current_Gate")
                curr_interp_plot = customize_plot(curr_interp_plot, "InterpolatedCurrent", self.config["IV_PQC"])

                diffx_interp = np.diff(xnew)
                diffy_interp = np.diff(ynew)
                der_one_interp = diffy_interp / diffx_interp
                firstdev4_interp = np.insert(der_one_interp, 0, der_one_interp[0])
                points9 = (xnew, firstdev4_interp)
                dif_intep_plot = hv.Curve(points9)
                dif_intep_plot = customize_plot(dif_intep_plot, "FirstDerivativeCurrent", self.config["IV_PQC"])

                diffy_interp2 = np.diff(ynew,n=2)
                diffy_interp2_add = np.insert(diffy_interp2, 0, diffy_interp2[0])
                der_two_interp = diffy_interp2_add / diffx_interp
                firstdev5_interp = np.insert(der_two_interp, 0, der_two_interp[0])
                points10 = (xnew, firstdev5_interp)
                dif2_intep_plot = hv.Curve(points10)
                dif2_intep_plot = customize_plot(dif2_intep_plot, "SecondDerivativeCurrent", self.config["IV_PQC"])

                max1_index = list(der_one_interp).index(max(der_one_interp))
                min1_index = list(der_one_interp).index(min(der_one_interp))
                if min1_index<max1_index:
                    min1_index = max1_index+1
                    max1_index = min1_index - 2
                median_index = int(len(xnew)/2)
                if median_index<max1_index:
                    median_index = max1_index+1
                if min1_index<median_index:
                    min1_index = median_index+1
                    max1_index = median_index-1


                interesting_section = sorted(list(der_two_interp[max1_index:median_index]),reverse=True)
                firstminimum = interesting_section[0]
                interesting_section2 = sorted(list(der_two_interp[median_index:min1_index]),reverse=True)
                second_minimum = interesting_section2[0]

                start_average = list(der_two_interp).index(firstminimum)
                end_average = list(der_two_interp).index(second_minimum)


                dy1 = np.diff(self.data[df]["data"][
                                  "Current"])  # compute the difference between each consecutive Capacity value and store it into an array with length i-1
                dx1 = np.diff(self.data[df]["data"]["Voltage"])  # compute the difference between each consecutive voltage value and store it into an array with length i-1
                der1 = dy1 / dx1
                firstdev3 = np.insert(der1, 0, der1[0])  # Add an element to the array to have the same number of rows as in df
                # insert first derivative into dataframe
                self.data[df]["data"].insert(3, "firstderivative_gate", firstdev3)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("firstderivative_gate")

                I_surf_maxima_average = np.mean(list(ynew[start_average:end_average]))

                mxx = max(ynew) # find maximum of value of the current-voltage curve
                minx = np.mean(list(ynew[-1000:])) # find the minimum of the current-voltage curve by averaging 20 points values in the curve tail
                I_surf_average = I_surf_maxima_average - minx
                I_surf_average_table = '{:.2e}'.format(I_surf_average)
                Surface_current_average.append(I_surf_average_table)

                Isurf_max = mxx - minx # compute the surface current
                Isurf_table = '{:.2e}'.format(Isurf_max)
                Surface_current.append(Isurf_table)
                S_null_max = Isurf_max/(self.config['IV_PQC_parameter']['q'] * self.config['IV_PQC_parameter']['n_i_intrinsic_carrier_concentration'] * (float(self.data[df]['header'][0].split(':')[1]) *(1e-8)))
                Surface_recombination_velocity.append(S_null_max)
                S_null_average = I_surf_average/(self.config['IV_PQC_parameter']['q'] * self.config['IV_PQC_parameter']['n_i_intrinsic_carrier_concentration'] * (float(self.data[df]['header'][0].split(':')[1])  *(1e-8)))
                Surface_recombination_velocity_average.append(S_null_average)

                # Add text to the plot
                text = hv.Text(3, 9 * (1e-11), 'Isurf_max: {} A\n'
                               'Isurf_average: {} A\n'
                               'Surface recombination velocity_max: {} cm/s\n'
                               'Surface recombination velocity_average: {} cm/s'.format(
                    np.round(Isurf_max, 15), np.round(I_surf_average, 15) , np.round(S_null_max,4), np.round(S_null_average,4))
                               ).opts(style=dict(text_font_size='20pt'))


                #do this if the analysis is of just one file
                if len(gate) == 1:
                    # Plot all Measurements
                    self.donts11 = ["timestamp", "voltage", "Voltage", 'Current', "Stepsize", "Wait", "Stepsize",
                                    "Frequency", 'x', 'N']

                    Path_min = hv.Path([(-2, minx), (6, minx)]).opts(line_width=2.0)
                    Path_mxx = hv.Path([(-2, mxx), (6, mxx)]).opts(line_width=2.0)
                    Path_savgolmax = hv.Path([(-2,maxsavgol),(6,maxsavgol)])
                    Path_average = hv.Path([(-2, I_surf_maxima_average), (6, I_surf_maxima_average)]).opts(line_width=2.0)
                    Path_Isurf = hv.Arrow(-1, mxx,'max','^')
                    Path_Isurf_average = hv.Arrow(0, I_surf_maxima_average,'average','^')
                    self.PlotDict["BasePlots_gate"] = plot_not_kink
                    self.PlotDict["BasePlots_gate"] += dif_intep_plot
                    self.PlotDict["BasePlots_gate"] += dif2_intep_plot
                    self.PlotDict["BasePlots_gate"] += curr_interp_plot
                    try:
                        self.PlotDict["BasePlots_gate"] += curr_savgol_plot
                        self.PlotDict["BasePlots_gate"] += curr_savgol_plot* plot_not_kink
                    except:
                        print('exception savgol plot')
                    self.PlotDict["BasePlots_gate"] += text* curr_interp_plot *plot_not_kink *Path_min * Path_mxx * Path_average *Path_Isurf *Path_Isurf_average *Path_savgolmax
                    self.PlotDict["BasePlots_gate"] += curr_interp_plot * dif_intep_plot *dif2_intep_plot * plot_not_kink#curr_savgol_plot# * Path_Isurf #self.basePlots3.Curve.Current_Gate *


                    #add table that shows resulting parameters of the analysis
                    count3 += 1
                    df4 = pd.DataFrame({"Name": gate, "Surface current_max (A)": Surface_current, "Surface current_average (A)": Surface_current_average,
                                        'Surface recombination velocity_max (cm/s)': Surface_recombination_velocity, 'Surface recombination velocity_average (cm/s)': Surface_recombination_velocity_average })
                    table3 = hv.Table((df4), label = 'Gate analysis')
                    table3.opts(width=1300, height=800)
                    self.PlotDict["BasePlots_gate"] += table3

                # do this if the analysis is of more than one file
                elif len(gate) > 1:
                    self.basePlots3 = plot_all_measurements(self.data, self.config, self.xaxis, self.name,
                                                            do_not_plot=self.donts, keys=gate)


                    self.PlotDict["BasePlots_gate"] = self.basePlots3
                    # add table that shows resulting parameters of the analysis
                    count3 += 1
                    df4 = pd.DataFrame({"Name": gate, "Surface current_max (A)": Surface_current, "Surface current_average (A)": Surface_current_average,
                                        'Surface recombination velocity_max (cm/s)': Surface_recombination_velocity, 'Surface recombination velocity_average (cm/s)': Surface_recombination_velocity_average })
                    table3 = hv.Table((df4), label = 'Gate analysis')
                    table3.opts(width=1300, height=800)
                    self.PlotDict["BasePlots_gate"] += table3

        if count != 0 and count2 !=0 and count3 != 0:
            self.PlotDict['All'] =  self.PlotDict["BasePlots_gate"] + self.PlotDict["BasePlots_diode"] + self.PlotDict["BasePlots_MOS"]
        elif count != 0 and count2 !=0 and count3 == 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_diode"] + self.PlotDict["BasePlots_MOS"]

        elif count == 0 and count2 !=0 and count3 == 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_diode"]
        elif count != 0 and count2 ==0 and count3 == 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_MOS"]

        elif count == 0 and count2 ==0 and count3 != 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_gate"]
        elif count != 0 and count2 ==0 and count3 != 0:
            self.PlotDict['All'] =  self.PlotDict["BasePlots_gate"] + self.PlotDict["BasePlots_MOS"]
        else:
            self.PlotDict['All'] = self.PlotDict["BasePlots_diode"] + self.PlotDict["BasePlots_gate"]

        self.PlotDict["All"] = applyPlotOptions(self.PlotDict["All"],
                                                {'Curve': {'color': "hv.Palette('Category20')"}}) # To change colors

        return self.PlotDict

    def find_flatBand_voltage(self, plot, data, configs, indexMax, indexMin, df,cv, xvals2, **addConfigs,):
        """
        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the
        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.
        :param plot: The plot object
        :param data: The data files
        :param configs: the configs
        :param **addConfigs: the configs special for the 1/C2 plot, it is recommended to pass the same options here again, like in the original plot!
        :return: The updated plot
        """

        self.log.info("Searching for flat band voltage voltage in all files...")

        sample = deepcopy(data[df])
        #Create a new data frame with just two columns
        try:
            df1 = pd.DataFrame({"xaxis": sample["data"]["voltage"], "yaxis": sample["data"]["CapacityCopy"]})
        except:
            df1 = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["CapacityCopy"]})
        df1 = df1.dropna()

        # Loop one time from the right side, to get the slope of the accumulation region, and then loop on the fit region to get the fit slope
        RR2 = 0
        fitR2 = 0
        for idx in range(5, len(df1)-5):
            # Right
            slope_right, intercept_right, r_right, p_value, std_err_right = linregress(df1["xaxis"][idx:],df1["yaxis"][idx:])
            r2_right = r_right * r_right
            self.log.debug("Right side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                slope_right, intercept_right, r2_right, std_err_right)
            )
            # See if the r2 value has increased and store it
            if r2_right >= RR2:
                RR2 = r2_right
                RightEndPoints = (
                    (df1["xaxis"][idx], slope_right * df1["xaxis"][idx] + intercept_right),
                    (df1["xaxis"][len(df1["xaxis"]) - 1], slope_right * df1["xaxis"][len(df1["xaxis"]) - 1] + intercept_right),
                )
                Right_stats = [RightEndPoints, slope_right, intercept_right, r_right, p_value, std_err_right]


        # Fit central region
        for idx in range(indexMax, indexMin-1):
            #Central fit
            slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit = linregress(df1["xaxis"][idx:indexMin-1],
                                                                                  df1["yaxis"][idx:indexMin-1])
            r2_fit = r_fit * r_fit
            self.log.debug("central fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                slope_fit, intercept_fit, r2_fit, std_err_fit)
            )
            # See if the r2 value has increased and store it
            if r2_fit >= fitR2:
                fitR2 = r2_fit
                fitEndPoints = (
                    (df1["xaxis"][indexMax], slope_fit * df1["xaxis"][indexMax] + intercept_fit),
                    (df1["xaxis"][idx+1], slope_fit * df1["xaxis"][idx+1] + intercept_fit) # use idx +1 to avoid having the same end points
                )
                fit_stats = [fitEndPoints, slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit]


        # Add central slope
        xmax = df1["xaxis"][indexMin]

        fit_line = np.array([[df1["xaxis"][indexMax-3], fit_stats[1] * df1["xaxis"][indexMax-3]  + fit_stats[2]],
                               [xmax+0.2, fit_stats[1] * (xmax+0.2) + fit_stats[2]]])

        # Add right slope
        xmax = df1["xaxis"][len(df1["yaxis"]) - 1]
        right_line = np.array([[df1["xaxis"][indexMax-3], Right_stats[1] *df1["xaxis"][indexMax-3] + Right_stats[2]],
                               [xmax, Right_stats[1] * xmax + Right_stats[2]]])



        # Compute the flatband voltage
        flatband_voltage = line_intersection(fit_stats[0], Right_stats[0])
        self.log.info("Flatband voltage to data file {} is {}".format(df,
                                                                                                     flatband_voltage[
                                                                                                          0]))



        # Find oxide thickness Tox in nm
        Accum_capacitance = np.max(df1["yaxis"]) * (float(self.data[df]['header'][0].split(':')[1]) * (
            1e-8))  # float(..) is the area.
        Accum_capacitance_table = '{:.2e}'.format(Accum_capacitance)
        Accum_capacitance_normalized = np.max(df1["yaxis"])  # F/cm^2
        Accum_capacitance_normalized_table = '{:.2e}'.format(Accum_capacitance_normalized)
        Tox = self.config['IV_PQC_parameter']['epsilonNull'] * self.config['IV_PQC_parameter'][
            'epsilonSiliconOxide'] * 1e+5 / Accum_capacitance_normalized
        Tox_table = '{:.2e}'.format(Tox)
        # Find Fixed oxide charge Nox in cm^-2
        phi_s = self.config['IV_PQC_parameter']['electronAffinity'] + self.config['IV_PQC_parameter'][
            'bandGapEnergy'] / 2 \
                + (self.config['IV_PQC_parameter']['boltzmannConstant'] * self.config['IV_PQC_parameter']['Temperature']
                   * np.log(self.config['IV_PQC_parameter']['SiliconDoping'] / self.config['IV_PQC_parameter'][
                    'intrinsicDopingConcentration'])) / self.config['IV_PQC_parameter']['q']
        phi_ms = self.config['IV_PQC_parameter']['phi_m'] - phi_s
        self.log.info("Test4 for flat band voltage voltage in all files...")
        Nox = (Accum_capacitance_normalized * (phi_ms + flatband_voltage[0])) / (self.config['IV_PQC_parameter']['q'])
        self.log.info("Test41 for flat band voltage voltage in all files...")
        Nox_table = '{:.2e}'.format(Nox)
        # Add text
        text = hv.Text(10, 0.00000000065, 'Flat band voltage_fit_2nd derivative: {} V \n'
                                            'Flat band voltage first derivative: {} V \n'

                                            'C accumulation: {} F \n'

                                            'C accumulation/A: {} F/cm\N{SUPERSCRIPT TWO} \n'

                                            'Tox: {} nm \n'
                                            'Nox: {} cm\N{SUPERSCRIPT MINUS}\N{SUPERSCRIPT TWO}'.format(
            np.round(np.median(flatband_voltage[0]), 2),
            np.round(xvals2, 2),
            np.round(Accum_capacitance, 10),
            np.round(Accum_capacitance_normalized, 10),
            np.round(Tox, 2),
            np.format_float_scientific(Nox, 2))

                       ).opts(style=dict(text_font_size='25pt'))


        #if more than one file do not do the derivates plot
        if not len(cv) == 1:

            returnPlot = plot
            returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)

            return returnPlot, flatband_voltage[0], Accum_capacitance_table, Accum_capacitance_normalized_table, Tox_table, Nox_table



        elif len(cv) == 1:
            #plot a vertical line where the fb voltage is
            vline = hv.VLine(flatband_voltage[0]).opts(color='black', line_width=1.0)


            # Plots of the derivatives
            secondDerivativePlot = self.basePlots5.Curve.secondderivative
            # Plots of the fits
            right_line = hv.Curve(right_line).opts(color='blue',line_width=1.0)
            fit_line = hv.Curve(fit_line).opts(color='red', line_width=1.5)

            returnPlot = plot * right_line * fit_line  * secondDerivativePlot * vline
            returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)
            returnplot2 = plot * fit_line * right_line *vline *text

            return returnPlot, flatband_voltage[0], Accum_capacitance_table, Accum_capacitance_normalized_table, Tox_table, Nox_table, returnplot2



    def find_full_depletion_c2(self, plot, data, configs,diode, **addConfigs):

        """

        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the

        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.

        :param plot: The plot object

        :param data: The data files

        :param configs: the configs

        :param **addConfigs: the configs special for the 1/C2 plot, it is recomended to pass the same options here again, like in the original plot!

        :return: The updated plot

        """

        full_depletion_voltages = np.zeros((len(diode), 2))

        Left_stats = np.zeros((len(diode), 6), dtype=np.object)

        self.log.info("Searching for full depletion voltage in all files...")

        for i, samplekey in enumerate(diode):

            if "1C2" not in data[samplekey]["data"]:

                self.log.warning("Full depletion calculation could not be done for data set: {}".format(samplekey))

            else:

                self.log.debug("Data: {}".format(samplekey))

                sample = deepcopy(data[samplekey])

                df = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["1C2"]})

                df = df.dropna()

                # Loop one time from the right side and from the left, to get both slopes

                LR2 = 0 # r^2 values for both sides


                for idx in range(5, len(df)-5):

                    # Left

                    slope_left, intercept_left, r_left, p_value, std_err_left = linregress(df["xaxis"][:-idx],df["yaxis"][:-idx])

                    r2_left = r_left * r_left

                    self.log.debug("Left side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(

                        slope_left, intercept_left, r2_left, std_err_left)

                    )


                    # See if the r2 value has increased and store end points

                    if r2_left >= LR2:

                        LR2 = r2_left

                        LeftEndPoints = (

                            (df["xaxis"][0], intercept_left),

                            (df["xaxis"][idx], slope_left * df["xaxis"][idx] + intercept_left)

                        )

                        Left_stats[i] = (LeftEndPoints, slope_left, intercept_left, r_left, p_value, std_err_left)


        average_right = np.mean(list(df['yaxis'][-20:]))
        RightEndPoints =[(df['xaxis'][len(df['xaxis'])-20],average_right),(df['xaxis'][len(df['xaxis'])-1],average_right)]
        # Find the line intersection
        full_depletion_voltages[i] = line_intersection(LeftEndPoints, RightEndPoints)



        # Add vertical line for full depletion

        # Find nonzero indizes

        valid_indz = np.nonzero(full_depletion_voltages[:, 0])

        vline = hv.VLine(np.median(full_depletion_voltages[valid_indz], axis=0)[0]).opts(color='black', line_width=5.0)


        # Add slopes

        left_line = np.array([[0, np.median(Left_stats[:,2])],[full_depletion_voltages[0][0], full_depletion_voltages[0][1]]])

        left_line = hv.Curve(left_line).opts(color='grey')

        right_line = hv.HLine(average_right).opts(color='grey')

        # Add text

        self.log.info('Full depletion voltage: {} V'

                        .format(np.round(np.median(full_depletion_voltages[valid_indz, 0]), 2)))


        text = hv.Text(230, (5e+21), 'Depletion voltage: {} V'.format(np.round(np.median(full_depletion_voltages[:, 0]), 2))).opts(style=dict(text_font_size='20pt'))


        # Update the plot specific options if need be

        returnPlot = plot * vline * right_line * left_line * text

        returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)

        return returnPlot, full_depletion_voltages[0][0]
