"""This script plots IVCV files together for files generated by QTC
Data must be """

import logging, os
import holoviews as hv
from holoviews import opts
from scipy.stats import linregress
from copy import deepcopy

import pandas as pd
import numpy as np
hv.extension('bokeh', 'matplotlib')

from forge.tools import customize_plot, holoplot, convert_to_df, config_layout, applyPlotOptions
from forge.tools import twiny, relabelPlot
from forge.tools import plot_all_measurements, convert_to_EngUnits
from forge.specialPlots import dospecialPlots
from forge.utilities import line_intersection


class IV_PQC:

    def __init__(self, data, configs):

        self.log = logging.getLogger(__name__)
        self.data = convert_to_df(data, abs=False, keys="all")
        self.config = configs
        self.df = []
        self.basePlots = None
        self.basePlots_2 = None
        self.name = "IV_PQC"
        self.PlotDict = {"Name": "IV"}
        self.capincluded = False

        # add a copyCapacity, first and second derivatives for the cv_mos anlaysis to the data frame;
        # add a 1/C2, the derivative of 1/C2, add the deep x and the surface doping profile N to the data frame;

        if "Capacity" in self.data[self.data["keys"][0]]["data"]:
            self.data["columns"].insert(3, "CapacityCopy")
            self.data["columns"].insert(4, "derivative")
            self.data["columns"].insert(5, "derivative2")
            self.data["columns"].insert(6, "1C2")
            self.data["columns"].insert(7,"derivative1C2")
            self.data["columns"].insert(8, "x")
            self.data["columns"].insert(9, "N")
            self.capincluded = True




        self.measurements = self.data["columns"]
        self.xaxis = self.measurements[0]
        self.donts = ["timestamp", "voltage","Voltage","Stepsize","Wait","Stepsize","Frequency",'x','N'] #do not plot this data
        hv.renderer('bokeh')

        # Convert the units to the desired ones
        for meas in self.measurements:
            unit = self.config[self.name].get(meas, {}).get("UnitConversion", None)
            if unit:
                self.data = convert_to_EngUnits(self.data, meas, unit)



    def run(self):
        """Runs the script"""
        fbvoltage = [] #list that is used later on to store the flat band voltage values for all the different files used in the analysis
        Accum_capacitance = [] #list that is used later on to store the accumulation capacitance values for all the different files used in the analysis
        Accum_capacitance_normalized = [] #list that is used later on to store the area-normalized accumulation capacitance values for all the different files used in the analysis
        Tox = [] #list that is used later on to store the oxide thickness values for all the different files used in the analysis
        Nox = [] #list that is used later on to store the oxide charge values for all the different files used in the analysis
        fdepvoltage = [] #list that is used later on to store the full depletion  voltage values for all the different files used in the analysis
        count = 0
        count2 = 0
        count3 = 0
        diode = []
        cv = []
        gate = []

        #self.basePlots = plot_all_measurements(self.data, self.config, self.xaxis, self.name,
        #                                       do_not_plot=self.donts)
        #self.PlotDict["BasePlots"] = self.basePlots
        #self.PlotDict["All"] = self.basePlots

        # Add the 1/c^2 data to the dataframes
        # Add a copy of the Capacity values to the data frame, where the small kink in the plot is deleted
        for df in self.data["keys"]:

            # Start the cv_mos analysis

            if "Capacity" in self.data[df]["data"]:
                if not df[0:8] == 'CV_Diode' or df[0:5] == 'IV_GCD': #If not Diode or Gate analysis do the cv mos analysis
                    cv.append(df)
                    if 'Voltage' in self.data[df]['data']: # Check that the voltage values have increasing order
                        if self.data[df]["data"]["Voltage"][0] > 0:
                            self.data[df]["data"]["Voltage"] = list(reversed(self.data[df]["data"]["Voltage"])) #if decreasing order, reverse it.
                            self.data[df]["data"]["Capacity"] = list(reversed(self.data[df]["data"]["Capacity"]))
                    self.data[df]["data"]["Capacity"] = self.data[df]["data"]["Capacity"] / (float(self.data[df]['header'][0].split(':')[1])*(1e-8)) # Normalize by the Area and convert to cm^2
                    CapacityCopy = self.data[df]["data"]["Capacity"].copy()
                    capMin= np.max(self.data[df]["data"]["Capacity"][:20]) # Find the Maximum among the first 20 values of the Capacity and set it as minimum Capacity value
                    for x in range(len(self.data[df]["data"]["Capacity"])):
                        if CapacityCopy[x] < capMin:
                            CapacityCopy[x] = capMin
                    # insert into the data frame
                    self.data[df]["data"].insert(3, "CapacityCopy", CapacityCopy)
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("CapacityCopy")

                    #compute derivatives
                    dy1 = np.diff(self.data[df]["data"]["CapacityCopy"])  # compute the difference between each consecutive Capacity value and store it into an array with length i-1
                    dx1 = np.diff(self.data[df]["data"][self.xaxis])  # compute the difference between each consecutive voltage value and store it into an array with length i-1
                    der1 = dy1 / dx1
                    firstdev = np.insert(der1, 0, der1[0])  # Add an element to the array to have the same number of rows as in df
                    dy2 = np.diff(self.data[df]["data"]["CapacityCopy"],n=2)  # n=2 applies diff() two times to compute the second derivative, dy2 is of lenght i-2
                    dy2_2 = np.insert(dy2, 0, dy2[0])  # add one element to dy2 to have the same length of dx1
                    der2 = dy2_2 / dx1
                    seconddev = np.insert(der2, 0, der2[0])  # Add one element to the array to have the same number of rows as in df
                    # insert first derivative into dataframe
                    self.data[df]["data"].insert(4, "derivative", firstdev)
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("derivative")
                    # insert second derivative into dataframe
                    self.data[df]["data"].insert(5, "derivative2", seconddev)
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("derivative2")
                    # Find the index of the row which contains the maximum value of the second derivative
                    indexMax = self.data[df]['data'].index.get_loc(self.data[df]['data']['derivative2'].values.argmax())
                    # Find the index of the row which contains the minimum value of the second derivative
                    indexMin = self.data[df]['data'].index.get_loc(self.data[df]['data']['derivative2'].values.argmin())

                    # Plot all Measurements
                    self.donts2 = ["timestamp", "voltage", "Voltage", "Stepsize", "Wait", "Stepsize", "Frequency", 'x', 'N', 'Current']
                    self.basePlots5 = plot_all_measurements(self.data, self.config, self.xaxis, self.name, do_not_plot=self.donts2, keys = cv)
                    self.PlotDict["BasePlots_MOS"] = self.basePlots5
                    #self.PlotDict["All"] = self.basePlots

                    # Add flat bandage voltage point to the Capacity curve
                    if self.config["IV_PQC"].get("CapacityCopy", {}).get("findFlatBandVoltage", False):
                        try:
                            if self.basePlots5.Overlay.MOS_CV_CURVES.children:
                                clone_plot = self.basePlots5.Overlay.MOS_CV_CURVES.opts(clone=True)

                            else:
                                clone_plot = self.basePlots5.Curve.MOS_CV_CURVES.opts(clone=True)

                            fBestimation = self.find_flatBand_voltage(clone_plot, self.data, self.config, indexMax,indexMin, df, cv,
                                                                      PlotLabel="Flat band voltage estimation")

                            fbvoltage.append(fBestimation[1])
                            Accum_capacitance.append(fBestimation[2])
                            Accum_capacitance_normalized.append(fBestimation[3])
                            Tox.append(fBestimation[4])
                            Nox.append(fBestimation[5])

                            #self.PlotDict["All"] += fBestimation[0]
                            self.PlotDict["BasePlots_MOS"] += fBestimation[0]

                        except Exception as err:
                            self.log.warning("No flat band voltage calculation possible... Error: {}".format(err))


                    #Add a Table that shows the differents analysis parameters values
                    count += 1
                    df2 = pd.DataFrame(
                        {"Name": cv, "fbVoltage": fbvoltage, 'Accum_capacitance': Accum_capacitance,
                         'Accum_capacitance_normalized': Accum_capacitance_normalized, 'Tox': Tox, 'Nox': Nox})
                    table1 = hv.Table(df2)
                    table1.opts(width=1300, height=800)

                    #Do plots
                    #self.PlotDict["All"] += table1
                    self.PlotDict["BasePlots_MOS"] += table1

                    #self.PlotDict["All"] = applyPlotOptions(self.PlotDict["All"],
                    #                                        {'Curve': {'color': "hv.Palette('Category20')"}})


                # Start Diode Analysis
                elif df[0:8] == 'CV_Diode':
                    diode.append(df)
                    self.data[df]["data"]["Voltage"] = list(map(abs,self.data[df]["data"]["Voltage"])) #take absolute value of Voltage
                    self.data[df]["data"].insert(3, "1C2", 1 / self.data[df]["data"]["Capacity"].pow(2))
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("1C2")

                    #Compute derivative of 1/C2
                    invers_C2_dy = np.diff(self.data[df]["data"]["1C2"])
                    invers_C2_dx = np.diff(self.data[df]["data"][self.xaxis])
                    der_invers_C2 = invers_C2_dy/invers_C2_dx
                    firstdev_invers_C2 = np.insert(der_invers_C2, 0, der_invers_C2[0])  # Add an element to the array to have the same number of rows as in df
                    self.data[df]["data"].insert(4, "derivative1C2", firstdev_invers_C2)
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("derivative1C2")

                    #Calculate deep x
                    x = (self.config['IV_PQC_parameter']['epsilonNull']*(1e-6)* float(self.data[self.data['keys'][0]]['header'][0].split(':')[1]) \
                        * self.config['IV_PQC_parameter']['epsilonSiliconOxide']) / self.data[df]["data"]["Capacity"][:42]
                    self.data[df]['data'].insert(5, 'x', x)
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("x")

                    #Calculate doping profile
                    N = (2)/(self.config['IV_PQC_parameter']['epsilonNull']*(1e-2) \
                        * self.config['IV_PQC_parameter']['q'] * self.config['IV_PQC_parameter']['epsilonSiliconOxide'] * self.data[df]["data"]["derivative1C2"][:42] \
                                  *(float(self.data[self.data['keys'][0]]['header'][0].split(':')[1])*(1e-8))*(float(self.data[self.data['keys'][0]]['header'][0].split(':')[1])*(1e-8)))
                    self.data[df]['data'].insert(6, 'N', N)
                    self.data[df]["units"].append("arb. units")
                    self.data[df]["measurements"].append("N")


                    # Plot all Measurements
                    self.basePlots4 = plot_all_measurements(self.data, self.config, self.xaxis, self.name,
                                                           do_not_plot=self.donts, keys = diode )
                    self.PlotDict["BasePlots_diode"] = self.basePlots4
                    #self.PlotDict["All"] += self.basePlots
                    # Add plot with a different x axis
                    self.basePlots_2 = plot_all_measurements(self.data, self.config, 'x', self.name,
                                                             do_not_plot=['Voltage', 'Current', 'Capacity', '1C2',
                                                                          'derivative1C2', 'x'], keys = diode)
                    self.PlotDict["BasePlots_diode"] += self.basePlots_2

                    #self.PlotDict["All"] += self.basePlots_2

                    # Add full depletion point to 1/c^2 curve
                    if self.config["IV_PQC"].get("1C2", {}).get("DoFullDepletionCalculation", False):

                            try:

                                if self.basePlots4.Overlay.A_1C2.children:

                                    c2plot = self.basePlots4.Overlay.A_1C2.opts(
                                        clone=True)

                                else:
                                    c2plot = self.basePlots4.Curve.A_1C2.opts(clone=True)

                                fdestimation = self.find_full_depletion_c2(c2plot, self.data, self.config, diode,
                                                                           PlotLabel="Full depletion estimation")

                                fdepvoltage.append(fdestimation[1])

                                #self.PlotDict["All"] += fdestimation[0]

                                self.PlotDict["BasePlots_diode"] += fdestimation[0]

                            except Exception as err:

                                self.log.warning("No full depletion calculation possible... Error: {}".format(err))

                    # Find resistivity
                    C_min = np.mean(self.data[df]['data']['Current'][-20:])
                    d_active = self.config['IV_PQC_parameter']['epsilonNull'] * self.config['IV_PQC_parameter'][
                        'epsilonSiliconOxide'] * \
                               (float(self.data[self.data['keys'][0]]['header'][0].split(':')[1]) * (1e-8)) / C_min
                    rho = d_active * d_active / (
                                2 * self.config['IV_PQC_parameter']['epsilonNull'] * self.config['IV_PQC_parameter'][
                            'epsilonSiliconOxide'] * fdestimation[1]) # * u_mobility)

                    # TODO: add mobility in rho formula

                    resistivity = []
                    resistivity.append(rho)

                    #Add a table that show the results of the analysis
                    count2 += 1
                    df3 = pd.DataFrame({"Name": diode, "fdepvoltage": fdepvoltage, "resistivity": resistivity})
                    table2=hv.Table(df3)
                    table2.opts(width=1300, height=800)
                    #self.PlotDict["All"] += table2
                    self.PlotDict["BasePlots_diode"] += table2
                    #self.PlotDict["All"] = applyPlotOptions(self.PlotDict["All"],
                    #                                        {'Curve': {'color': "hv.Palette('Category20')"}})



            # Start Gate analysis
            else:
                gate.append(df)
                mxx = max(self.data[df]['data']['Current']) # find maximum of value of the current-voltage curve
                min = np.mean(self.data[df]['data']['Current'][-20:]) # find the minimum of the curr-voltage curve by averaging 20 points values in the curve tail
                Isurf = mxx - min # compute the surface current
                # S_null = Isurf/(self.config['IV_PQC_parameter']['q'] * self.config['IV_PQC_parameter']['n_i_intrinsic_carrier_concentration'] * 25000000 *(1e-8))
                # TODO: change area for surface recombination velocity

                # Add text to the plot
                text = hv.Text(0, 9 * (1e-11), 'Isurf: {} A'.format(
                    np.round(Isurf, 15)),
                               ).opts(style=dict(text_font_size='25pt'))
                # Plot all Measurements
                self.basePlots3 = plot_all_measurements(self.data, self.config, self.xaxis, self.name,
                                                       do_not_plot=self.donts, keys = gate)
                #do this if the analysis is of just one file
                if len(self.data["keys"]) == 1:
                    self.PlotDict["BasePlots_gate"] = self.basePlots3 *text
                    #self.PlotDict["All"] += self.basePlots *text
                    #self.PlotDict["All"] = config_layout(self.PlotDict["All"], **self.config[self.name].get("Layout", {}))
                    #self.PlotDict["All"] = applyPlotOptions(self.PlotDict["All"],
                    #                                {'Curve': {'color': "hv.Palette('Category20')"}}) #change color cycle

                    #add table that shows resulting parameters of the analysis
                    count3 += 1
                    df4 = pd.DataFrame({"Name": self.data['keys'][:count3], "Isurf": Isurf})
                    table3 = hv.Table(df4)
                    table3.opts(width=1300, height=800)
                    #self.PlotDict["All"] += table3
                    self.PlotDict["BasePlots_gate"] += table3

                # do this if the analysis is of more than one file
                elif len(self.data["keys"]) > 1:
                    self.PlotDict["BasePlots_gate"] = self.basePlots3 # *text
                    #self.PlotDict["All"] += self.basePlots   # *text
                    #self.PlotDict["All"] = config_layout(self.PlotDict["All"], **self.config[self.name].get("Layout", {}))
                    #self.PlotDict["All"] = applyPlotOptions(self.PlotDict["All"],
                    #                                {'Curve': {'color': "hv.Palette('Category20')"}})
                    # add table that shows resulting parameters of the analysis
                    count3 += 1
                    df4 = pd.DataFrame({"Name": gate, "Isurf": Isurf})
                    table3 = hv.Table(df4)
                    table3.opts(width=1300, height=800)
                    #self.PlotDict["All"] += table3
                    self.PlotDict["BasePlots_gate"] += table3

        if count != 0 and count2 !=0 and count3 != 0:
            self.PlotDict['All'] =  self.PlotDict["BasePlots_gate"] + self.PlotDict["BasePlots_diode"] + self.PlotDict["BasePlots_MOS"]
        elif count != 0 and count2 !=0 and count3 == 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_diode"] + self.PlotDict["BasePlots_MOS"]

        elif count == 0 and count2 !=0 and count3 == 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_diode"]
        elif count != 0 and count2 ==0 and count3 == 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_MOS"]

        elif count == 0 and count2 ==0 and count3 != 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_gate"]
        elif count != 0 and count2 ==0 and count3 != 0:
            self.PlotDict['All'] = self.PlotDict["BasePlots_MOS"] + self.PlotDict["BasePlots_gate"]
        else:
            self.PlotDict['All'] = self.PlotDict["BasePlots_diode"] + self.PlotDict["BasePlots_gate"]


        return self.PlotDict

    def find_flatBand_voltage(self, plot, data, configs, indexMax, indexMin, df,cv, **addConfigs,):
        """
        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the
        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.
        :param plot: The plot object
        :param data: The data files
        :param configs: the configs
        :param **addConfigs: the configs special for the 1/C2 plot, it is recommended to pass the same options here again, like in the original plot!
        :return: The updated plot
        """

        self.log.info("Searching for flat band voltage voltage in all files...")

        sample = deepcopy(data[df])
        #Create a new data frame with just two columns
        try:
            df1 = pd.DataFrame({"xaxis": sample["data"]["voltage"], "yaxis": sample["data"]["CapacityCopy"]})
        except:
            df1 = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["CapacityCopy"]})
        df1 = df1.dropna()

        # Loop one time from the right side, to get the slope of the accumulation region, and then loop on the fit region to get the fit slope
        RR2 = 0
        fitR2 = 0
        for idx in range(5, len(df1)-5):
            # Right
            slope_right, intercept_right, r_right, p_value, std_err_right = linregress(df1["xaxis"][idx:],df1["yaxis"][idx:])
            r2_right = r_right * r_right
            self.log.debug("Right side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                slope_right, intercept_right, r2_right, std_err_right)
            )
            # See if the r2 value has increased and store it
            if r2_right >= RR2:
                RR2 = r2_right
                RightEndPoints = (
                    (df1["xaxis"][idx], slope_right * df1["xaxis"][idx] + intercept_right),
                    (df1["xaxis"][len(df1["xaxis"]) - 1], slope_right * df1["xaxis"][len(df1["xaxis"]) - 1] + intercept_right),
                )
                Right_stats = [RightEndPoints, slope_right, intercept_right, r_right, p_value, std_err_right]


        # Fit central region
        for idx in range(indexMax, indexMin-2):
            #Central fit
            slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit = linregress(df1["xaxis"][idx:indexMin-2],
                                                                                  df1["yaxis"][idx:indexMin-2])
            r2_fit = r_fit * r_fit
            self.log.debug("central fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                slope_fit, intercept_fit, r2_fit, std_err_fit)
            )
            # See if the r2 value has increased and store it
            if r2_fit >= fitR2:
                fitR2 = r2_fit
                fitEndPoints = (
                    (df1["xaxis"][indexMax], slope_fit * df1["xaxis"][indexMax] + intercept_fit),
                    (df1["xaxis"][idx+1], slope_fit * df1["xaxis"][idx+1] + intercept_fit) # use idx +1 to avoid having the same end points
                )
                fit_stats = [fitEndPoints, slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit]


        # Add central slope
        xmax = df1["xaxis"][indexMin]

        fit_line = np.array([[df1["xaxis"][indexMax-3], fit_stats[1] * df1["xaxis"][indexMax-3]  + fit_stats[2]],
                               [xmax+0.2, fit_stats[1] * (xmax+0.2) + fit_stats[2]]])

        # Add right slope
        xmax = df1["xaxis"][len(df1["yaxis"]) - 1]
        right_line = np.array([[df1["xaxis"][indexMax-3], Right_stats[1] *df1["xaxis"][indexMax-3] + Right_stats[2]],
                               [xmax, Right_stats[1] * xmax + Right_stats[2]]])

        self.log.info("Test3 for flat band voltage voltage in all files...")

        # Compute the flatband voltage
        flatband_voltage = line_intersection(fit_stats[0], Right_stats[0])
        self.log.info("Flatband voltage to data file {} is {}".format(df,
                                                                                                     flatband_voltage[
                                                                                                          0]))



        # Find oxide thickness Tox in nm
        Accum_capacitance = np.max(df1["yaxis"]) * (float(self.data[df]['header'][0].split(':')[1]) * (
            1e-8))  # float(..) is the area. Only valide if only one data file is used
        Accum_capacitance_normalized = np.max(df1["yaxis"])  # F/cm^2
        Tox = self.config['IV_PQC_parameter']['epsilonNull'] * self.config['IV_PQC_parameter'][
            'epsilonSiliconOxide'] * 1e+5 / Accum_capacitance_normalized

        # Find Fixed oxide charge Nox in cm^-2
        phi_s = self.config['IV_PQC_parameter']['electronAffinity'] + self.config['IV_PQC_parameter'][
            'bandGapEnergy'] / 2 \
                + (self.config['IV_PQC_parameter']['boltzmannConstant'] * self.config['IV_PQC_parameter']['Temperature']
                   * np.log(self.config['IV_PQC_parameter']['SiliconDoping'] / self.config['IV_PQC_parameter'][
                    'intrinsicDopingConcentration'])) / self.config['IV_PQC_parameter']['q']
        phi_ms = self.config['IV_PQC_parameter']['phi_m'] - phi_s
        self.log.info("Test4 for flat band voltage voltage in all files...")
        Nox = (Accum_capacitance_normalized * (phi_ms + flatband_voltage[0])) / (self.config['IV_PQC_parameter']['q'])
        self.log.info("Test41 for flat band voltage voltage in all files...")
        # Add text
        text = hv.Text(-2.5, 0.00000000065, 'Flat band voltage: {} V \n'

                                            'C accumulation: {} F \n'

                                            'C accumulation/A: {} F/cm\N{SUPERSCRIPT TWO} \n'

                                            'Tox: {} nm \n'
                                            'Nox: {} cm\N{SUPERSCRIPT MINUS}\N{SUPERSCRIPT TWO}'.format(
            np.round(np.median(flatband_voltage[0]), 2),
            np.round(Accum_capacitance, 10),
            np.round(Accum_capacitance_normalized, 10),
            np.round(Tox, 2),
            np.format_float_scientific(Nox, 2))

                       ).opts(style=dict(text_font_size='25pt'))
        self.log.info("Test42 for flat band voltage voltage in all files...")

        #if more than one file do not do the derivates plot
        if not len(cv) == 1:
            # Update the plot specific options if need be
            returnPlot = plot
            # returnPlot = relabelPlot(returnPlot, "MOS_CV CURVES - Full depletion calculation")
            returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)
            self.log.info("Test5 for flat band voltage voltage in all files...")
            return returnPlot, flatband_voltage[0], Accum_capacitance, Accum_capacitance_normalized, Tox, Nox



        elif len(cv) == 1:
            #plot a vertical line where the fb voltage is
            vline = hv.VLine(flatband_voltage[0]).opts(color='black', line_width=2.0)

            self.log.info("Test43 for flat band voltage voltage in all files...")
            # Plots of the derivatives
            firstDerivativePlot= self.basePlots5.Curve.firstderivative
            secondDerivativePlot = self.basePlots5.Curve.secondderivative
            # Plots of the fits
            right_line = hv.Curve(right_line).opts(color='blue')
            fit_line = hv.Curve(fit_line).opts(color='red')
            self.log.info("Test44 for flat band voltage voltage in all files...")
            # Update the plot specific options if need be
            returnPlot = plot * right_line * fit_line * text * secondDerivativePlot * firstDerivativePlot * vline
            # returnPlot = relabelPlot(returnPlot, "MOS_CV CURVES - Full depletion calculation")
            returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)
            self.log.info("Test5 for flat band voltage voltage in all files...")
            return returnPlot, flatband_voltage[0], Accum_capacitance, Accum_capacitance_normalized, Tox, Nox



    def find_full_depletion_c2(self, plot, data, configs,diode, **addConfigs):

        """

        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the

        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.

        :param plot: The plot object

        :param data: The data files

        :param configs: the configs

        :param **addConfigs: the configs special for the 1/C2 plot, it is recomended to pass the same options here again, like in the original plot!

        :return: The updated plot

        """



        full_depletion_voltages = np.zeros((len(diode), 2))

        Left_stats = np.zeros((len(diode), 6), dtype=np.object)

        Right_stats = np.zeros((len(diode), 6), dtype=np.object)

        self.log.info("Searching for full depletion voltage in all files...")



        for i, samplekey in enumerate(diode):

            if "1C2" not in data[samplekey]["data"]:

                self.log.warning("Full depletion calculation could not be done for data set: {}".format(samplekey))



            else:

                self.log.debug("Data: {}".format(samplekey))

                sample = deepcopy(data[samplekey])

                df = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["1C2"]})

                df = df.dropna()





                # Loop one time from the right side and from the left, to get both slopes

                LR2 = 0 # r^2 values for both sides

                RR2 = 0





                for idx in range(5, len(df)-5):

                    # Left

                    slope_left, intercept_left, r_left, p_value, std_err_left = linregress(df["xaxis"][:-idx],df["yaxis"][:-idx])

                    r2_left = r_left * r_left

                    self.log.debug("Left side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(

                        slope_left, intercept_left, r2_left, std_err_left)

                    )



                    # Right

                    slope_right, intercept_right, r_right, p_value, std_err_right = linregress(df["xaxis"][idx:],df["yaxis"][idx:])

                    r2_right = r_right * r_right

                    self.log.debug("Right side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(

                        slope_right, intercept_right, r2_right, std_err_right)

                    )



                    # See if the r2 value has increased and store end points

                    if r2_left >= LR2:

                        LR2 = r2_left

                        LeftEndPoints = (

                            (df["xaxis"][0], intercept_left),

                            (df["xaxis"][idx], slope_left * df["xaxis"][idx] + intercept_left)

                        )

                        Left_stats[i] = (LeftEndPoints, slope_left, intercept_left, r_left, p_value, std_err_left)



                    # See if the r2 value has increased and store it

                    if r2_right >= RR2:

                        RR2 = r2_right

                        RightEndPoints = (

                            (df["xaxis"][idx], slope_right * df["xaxis"][idx] + intercept_right),

                            (df["xaxis"][len(df["xaxis"]) - 1], slope_right * df["xaxis"][len(df["xaxis"]) - 1] + intercept_right),

                        )

                        Right_stats[i] = (RightEndPoints, slope_right, intercept_right, r_right, p_value, std_err_right)



                # Make the line intersection

                full_depletion_voltages[i] = line_intersection(LeftEndPoints, RightEndPoints)



        # Add vertical line for full depletion

        # Find nonzero indizes

        valid_indz = np.nonzero(full_depletion_voltages[:, 0])

        vline = hv.VLine(np.median(full_depletion_voltages[valid_indz], axis=0)[0]).opts(color='black', line_width=5.0)



        # Add slopes

        xmax = df["xaxis"][len(df["yaxis"])-1]

        left_line = np.array([[0, np.median(Left_stats[:,2])],[xmax, np.median(Left_stats[:,1])*xmax + np.median(Left_stats[:,2])]])

        left_line = hv.Curve(left_line).opts(color='grey')



        right_line = np.array([[0, np.median(Right_stats[:,2])],[xmax, np.median(Right_stats[:,1])*xmax + np.median(Right_stats[:,2])]])

        right_line = hv.Curve(right_line).opts(color='grey')



        # Add text

        self.log.info('Full depletion voltage: {} V, '

                        'Error: {} V'.format(np.round(np.median(full_depletion_voltages[valid_indz, 0]), 2),

                                           np.round(np.std(full_depletion_voltages[valid_indz, 0]), 2)))

        text = hv.Text(700, 0.055, 'Depletion voltage: {} V \n'

                        'Error: {} V'.format(np.round(np.median(full_depletion_voltages[:, 0]), 2),

                                           np.round(np.std(full_depletion_voltages[valid_indz, 0]), 2))

                       ).opts(fontsize=30)





        # Update the plot specific options if need be

        returnPlot = plot * vline * right_line * left_line * text

        #returnPlot = relabelPlot(returnPlot, "CV CURVES - Full depletion calculation")

        returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)


        self.log.info("Test1 for flat band voltage voltage in all files...")

        return returnPlot, full_depletion_voltages[0][0]



