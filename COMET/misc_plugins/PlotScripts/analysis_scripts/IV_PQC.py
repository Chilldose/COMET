"""This script plots IVCV files together for files generated by QTC
Data must be """

import logging, os
import holoviews as hv
from holoviews import opts
from scipy.stats import linregress
from copy import deepcopy

import pandas as pd
import numpy as np
hv.extension('bokeh', 'matplotlib')

from forge.tools import customize_plot, holoplot, convert_to_df, config_layout
from forge.tools import twiny, relabelPlot
from forge.tools import plot_all_measurements, convert_to_EngUnits
from forge.specialPlots import dospecialPlots
from forge.utilities import line_intersection


class IV_PQC:

    def __init__(self, data, configs):

        self.log = logging.getLogger(__name__)
        self.data = convert_to_df(data, abs=False, keys="all")
        self.config = configs
        self.df = []
        self.basePlots = None
        self.name = "IV_PQC"
        self.PlotDict = {"Name": "IV"}
        self.capincluded = False

        # add a copy of capacitance and derivatives to the data

        if "capacitance" in self.data[self.data["keys"][0]]["data"]:
            self.data["columns"].insert(3, "capacitance2")
            self.data["columns"].insert(4, "derivative")
            self.data["columns"].insert(5, "derivative2")
            self.capincluded = True
        elif "Capacity" in self.data[self.data["keys"][0]]["data"]:
            self.data["columns"].insert(3, "capacitance2")
            self.data["columns"].insert(4, "derivative")
            self.data["columns"].insert(5, "derivative2")
            self.capincluded = True




        self.measurements = self.data["columns"]
        self.xaxis = self.measurements[0]
        self.donts = ["timestamp", "voltage","current","Current","Voltage","Stepsize","Wait","Stepsize","Frequency"]
        hv.renderer('bokeh')



        # Convert the units to the desired ones
        for meas in self.measurements:
            unit = self.config[self.name].get(meas, {}).get("UnitConversion", None)
            if unit:
                self.data = convert_to_EngUnits(self.data, meas, unit)



    def run(self):
        """Runs the script"""

        # Add a copy of the capacitance values to the data frame, where the small peak in the plot is deleted
        for df in self.data["keys"]:

            if "capacitance" in self.data[df]["data"]:
                capacitance2 = self.data[df]["data"]["capacitance"].copy()
                capMin= np.max(self.data[df]["data"]["capacitance"][:20])
                for x in range(len(self.data[df]["data"]["capacitance"])):
                    if capacitance2[x] < capMin :
                        capacitance2[x] = capMin
                self.data[df]["data"].insert(3, "capacitance2", capacitance2)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("capacitance2")
            elif "Capacity" in self.data[df]["data"]:
                capacitance2 = self.data[df]["data"]["Capacity"].copy()
                capMin= np.max(self.data[df]["data"]["Capacity"][:20])
                for x in range(len(self.data[df]["data"]["Capacity"])):
                    if capacitance2[x] < capMin :
                        capacitance2[x] = capMin
                self.data[df]["data"].insert(3, "capacitance2", capacitance2)
                self.data[df]["units"].append("arb. units")
                self.data[df]["measurements"].append("capacitance2")


        # Add the first and second derivative data to the dataframes

        for df in self.data["keys"]:

            if "capacitance2" in self.data[df]["data"]:

                der1 = 5*np.diff(self.data[df]["data"]["capacitance2"],n=1)
                firstdev = np.insert(der1,0,der1[0]) # Add an element to the array to have the same number of rows as in df

                der2= 15*np.diff(self.data[df]["data"]["capacitance2"],n=2)
                seconddev1=  np.insert(der2,0,der2[0]) # Add two elements to the array to have the same number of rows as in df
                seconddev= np.insert(seconddev1,0,seconddev1[0])

                self.data[df]["data"].insert(4, "derivative", firstdev)

                self.data[df]["units"].append("arb. units")

                self.data[df]["measurements"].append("derivative")

                self.data[df]["data"].insert(5, "derivative2", seconddev)

                self.data[df]["units"].append("arb. units")

                self.data[df]["measurements"].append("derivative2")


                ## Find the index of the row of the maximum of the second derivative
                indexMax = self.data[df]['data'].index.get_loc(
                    self.data[df]['data']['derivative2'].values.argmax())

                ## Find the index of the row of the minimum of the second derivative
                indexMin = self.data[df]['data'].index.get_loc(
                    self.data[df]['data']['derivative2'].values.argmin())



        # Plot all Measurements
        self.basePlots = plot_all_measurements(self.data, self.config, self.xaxis, self.name, do_not_plot = self.donts)
        self.PlotDict["BasePlots"] = self.basePlots
        self.PlotDict["All"] = self.basePlots

        # Add flat bandage voltage point point to capacitance curve
        if self.config["IV_PQC"].get("capacitance2", {}).get("findFlatBandVoltage", False):
            try:

                if self.basePlots.Overlay.CV_CURVES.children:

                    c2plot = self.basePlots.Overlay.CV_CURVES.opts(clone=True)

                else:
                    c2plot = self.basePlots.Curve.CV_CURVES.opts(clone=True)

                fBestimation = self.find_flatBand_voltage(c2plot, self.data, self.config, indexMax, indexMin,
                                                        PlotLabel="Flat band voltage estimation")

                self.PlotDict["All"] += fBestimation

                self.PlotDict["BasePlots"] += fBestimation



            except Exception as err:
                self.log.warning("No flat band voltage calculation possible... Error: {}".format(err))


        # Reconfig the plots to be sure
        self.PlotDict["All"] = config_layout(self.PlotDict["All"], **self.config[self.name].get("Layout", {}))

        return self.PlotDict

    def find_flatBand_voltage(self, plot, data, configs, indexMax, indexMin, **addConfigs):
        """
        Finds the full depletion voltage of all data samples and adds a vertical line for the full depletion in the
        plot. Vertical line is the mean of all measurements. Furthermore, adds a text with the statistics.
        :param plot: The plot object
        :param data: The data files
        :param configs: the configs
        :param **addConfigs: the configs special for the 1/C2 plot, it is recomended to pass the same options here again, like in the original plot!
        :return: The updated plot
        """
        flatband_voltage = np.zeros((len(data["keys"]), 2))
        Right_stats = np.zeros((len(data["keys"]), 6), dtype=np.object)
        fit_stats = np.zeros((len(data["keys"]), 6), dtype=np.object)
        self.log.info("Searching for flat band voltage voltage in all files...")

        for i, samplekey in enumerate(data["keys"]):
            if "capacitance2" not in data[samplekey]["data"]:
                self.log.warning("Flat band voltage calculation could not be done for data set: {}".format(samplekey))

            else:
                self.log.debug("Data: {}".format(samplekey))
                sample = deepcopy(data[samplekey])
                try:
                    df = pd.DataFrame({"xaxis": sample["data"]["voltage"], "yaxis": sample["data"]["capacitance2"]})
                except:
                    df = pd.DataFrame({"xaxis": sample["data"]["Voltage"], "yaxis": sample["data"]["capacitance2"]})
                df = df.dropna()


                # Loop one time from the right side and from the left, to get both slopes
                RR2 = 0
                fitR2 = 0

                for idx in range(5, len(df)-5):
                    # Right
                    slope_right, intercept_right, r_right, p_value, std_err_right = linregress(df["xaxis"][idx:],df["yaxis"][idx:])
                    r2_right = r_right * r_right
                    self.log.debug("Right side fit: Slope {}, intercept: {}, r^2: {}, std: {}".format(
                        slope_right, intercept_right, r2_right, std_err_right)
                    )

                    # See if the r2 value has increased and store it
                    if r2_right >= RR2:
                        RR2 = r2_right
                        RightEndPoints = (
                            (df["xaxis"][idx], slope_right * df["xaxis"][idx] + intercept_right),
                            (df["xaxis"][len(df["xaxis"]) - 1], slope_right * df["xaxis"][len(df["xaxis"]) - 1] + intercept_right),
                        )
                        Right_stats[i] = (RightEndPoints, slope_right, intercept_right, r_right, p_value, std_err_right)



        ## Fit central region

                for idx in range(indexMax, indexMin-2):

                    #Central fit
                    slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit = linregress(df["xaxis"][idx:indexMin-2],
                                                                                          df["yaxis"][idx:indexMin-2])
                    r2_fit = r_fit * r_fit
                    if r2_fit >= fitR2:
                        fitR2 = r2_fit
                        fitEndPoints = (
                            (df["xaxis"][indexMax], slope_fit * df["xaxis"][indexMax] + intercept_fit),
                            (df["xaxis"][idx], slope_fit * df["xaxis"][idx] + intercept_fit)
                        )
                        fit_stats[i] = (fitEndPoints, slope_fit, intercept_fit, r_fit, p_valuefit, std_err_fit)

        ## Add slopes central
        xmax = df["xaxis"][indexMin]

        fit_line = np.array([[df["xaxis"][indexMax-3], np.median(fit_stats[:, 1]) *df["xaxis"][indexMax-3]  + np.median(fit_stats[:, 2])],
                               [xmax+0.2, np.median(fit_stats[:, 1]) * (xmax+0.2) + np.median(fit_stats[:, 2])]])


        ## Add slopes right
        xmax = df["xaxis"][len(df["yaxis"]) - 1]
        right_line = np.array([[df["xaxis"][indexMax-3],np.median(Right_stats[:, 1]) *df["xaxis"][indexMax-3]  + np.median(Right_stats[:, 2]) ],
                               [xmax, np.median(Right_stats[:, 1]) * xmax + np.median(Right_stats[:, 2])]])
        ##Plots
        right_line = hv.Curve(right_line).opts(color='blue')

        fit_line = hv.Curve(fit_line).opts(color='red')

        flatband_voltage[i]=line_intersection(fitEndPoints, RightEndPoints)



        # Add vertical line for full depletion

        # Find nonzero indices

        valid_indz = np.nonzero(flatband_voltage[:, 0])

        vline = hv.VLine(np.median(flatband_voltage[valid_indz], axis=0)[0]).opts(color='black', line_width=2.0)

        ###vline = hv.VLine(flatband_voltage[0]).opts(color='black', line_width=5.0)

        firstDerivativePlot= self.basePlots.Curve.firstderivative
        secondDerivativePlot = self.basePlots.Curve.secondderivative


        ## Find Tox
        epsilonNull = 8.85418e-12
        epsilonSiliconOxide = 3.9
        Areanm = 1.73056e+13
        #AreaFile3nm = 250000*250000 #area of a specif file, not to be used by you
        Cap = np.max(df["yaxis"])
        Tox = epsilonNull * epsilonSiliconOxide * Areanm / Cap


        # Find Nox
        q= 1.60217e-19
        #phi_ms = -0.68  #-0.68 is the usual value
        electronAffinity = 4.05
        bandGapEnergy = 1.12
        intrinsicDopingConcentration=1.45e10
        SiliconDoping = 5e12
        boltzmannConstant = 1.38064e-23
        Temperature = 20  #select temperature
        Areacm= 0.173056
        #AreaFile3cm = .25*.25 #area of a specif file, not to be used by you
        phi_s= electronAffinity + bandGapEnergy/2 + (boltzmannConstant*Temperature*np.log(SiliconDoping/intrinsicDopingConcentration))/q
        phi_ms2=4.08-phi_s

        Nox = (Cap*(phi_ms2 + flatband_voltage[0][0])*(1e-9))/(q*Areacm) #use (phi_ms-flatband_voltage[:, 0]) if n-type

        # Add text
        text = hv.Text(-.5, 0.35, 'Flat band voltage: {} V \n'

                        'C accumulation: {} nF  \n'
        
                       'Tox: {} nm \n'
                       'Nox: {} cm^-2'.format(np.round(np.median(flatband_voltage[:, 0]), 2),
                                           np.round(Cap, 2),
                                           np.round(Tox, 2),
                                           np.format_float_scientific(Nox, 2))

                       ).opts(style=dict(text_font_size='20pt'))


        # Update the plot specific options if need be
        returnPlot = plot * secondDerivativePlot * firstDerivativePlot * fit_line * right_line * vline * text
        #returnPlot = relabelPlot(returnPlot, "CV CURVES - Full depletion calculation")
        #returnPlot = customize_plot(returnPlot, "1C2", configs["IV_PQC"], **addConfigs)

        return returnPlot
